{"type":"Game","title":"Tower Blocks","desc":"How high will your tower be?","author":"Steve Gardner","src":"/assets/media/apps/external/towerblocks.png","id":"Tower BlocksYZ31V43W2D","batch":"","content":"<meta name=\"viewport\" content=\"width=device-width,user-scalable=no\">\n\n<div id=\"container\">\n\t<div id=\"game\"></div>\n\t<div id=\"score\">0</div>\n\t<div id=\"instructions\">Click (or press the spacebar) to place the block</div>\n\t<div class=\"game-over\">\n\t\t<h2>Game Over</h2>\n\t\t<p>You did great, you're the best.</p>\n\t\t<p>Click or spacebar to start again</p>\n\t</div>\n\t<div class=\"game-ready\">\n\t\t<div id=\"start-button\">Start</div>\n\t\t<div></div>\n\t</div>\n</div>\n<script type=\"text/javascript\">\nconsole.clear();\n\ninterface BlockReturn\n{\n\tplaced?:any;\n\tchopped?:any;\n\tplane: 'x' | 'y' | 'z';\n\tdirection: number;\n\tbonus?: boolean;\n}\n\nclass Stage\n{\n\tprivate container: any;\n\tprivate camera: any;\n\tprivate scene: any;\n\tprivate renderer: any;\n\tprivate light: any;\n\tprivate softLight: any;\n\tprivate group: any;\n\t\n\tconstructor()\n\t{\n\t\t// container\n\t\t\n\t\tthis.container = document.getElementById('game');\n\t\t\n\t\t// renderer\n\t\t\n\t\tthis.renderer = new THREE.WebGLRenderer({\n\t\t\tantialias: true,\n\t\t\talpha: false\n\t\t});\n\t\t\n\t\tthis.renderer.setSize(window.innerWidth, window.innerHeight);\n\t\tthis.renderer.setClearColor('#D0CBC7', 1);\n\t\tthis.container.appendChild( this.renderer.domElement );\n\t\t\n\t\t// scene\n\n\t\tthis.scene = new THREE.Scene();\n\n\t\t// camera\n\n\t\tlet aspect = window.innerWidth / window.innerHeight;\n\t\tlet d = 20;\n\t\tthis.camera = new THREE.OrthographicCamera( - d * aspect, d * aspect, d, - d, -100, 1000);\n\t\tthis.camera.position.x = 2;\n\t\tthis.camera.position.y = 2; \n\t\tthis.camera.position.z = 2; \n\t\tthis.camera.lookAt(new THREE.Vector3(0, 0, 0));\n\t\t\n\t\t//light\n\n\t\tthis.light = new THREE.DirectionalLight(0xffffff, 0.5);\n\t\tthis.light.position.set(0, 499, 0);\n\t\tthis.scene.add(this.light);\n\n\t\tthis.softLight = new THREE.AmbientLight( 0xffffff, 0.4 );\n\t\tthis.scene.add(this.softLight)\n\t\t\n\t\twindow.addEventListener('resize', () => this.onResize());\n\t\tthis.onResize();\n\t}\n\t\n\tsetCamera(y:number, speed:number = 0.3)\n\t{\n\t\tTweenLite.to(this.camera.position, speed, {y: y + 4, ease: Power1.easeInOut});\n\t\tTweenLite.to(this.camera.lookAt, speed, {y: y, ease: Power1.easeInOut});\n\t}\n\t\n\tonResize()\n\t{\n\t\tlet viewSize = 30;\n\t\tthis.renderer.setSize(window.innerWidth, window.innerHeight);\n\t\tthis.camera.left = window.innerWidth / - viewSize;\n\t\tthis.camera.right = window.innerWidth / viewSize;\n\t\tthis.camera.top = window.innerHeight / viewSize;\n\t\tthis.camera.bottom = window.innerHeight / - viewSize;\n\t\tthis.camera.updateProjectionMatrix();\n\t}\n\t\n\trender = function()\n\t{\n\t\tthis.renderer.render(this.scene, this.camera);\n\t}\n\n\tadd = function(elem)\n\t{\n\t\tthis.scene.add(elem);\n\t}\n\n\tremove = function(elem)\n\t{\n\t\tthis.scene.remove(elem);\n\t}\n}\n\nclass Block\n{\n\tconst STATES = {ACTIVE: 'active', STOPPED: 'stopped', MISSED: 'missed'};\n\tconst MOVE_AMOUNT = 12;\n\n\tdimension = { width: 0, height: 0, depth: 0}\n\tposition = {x: 0, y: 0, z: 0};\n\t\n\tmesh:any;\n\tstate:string;\n\tindex:number;\n\tspeed:number;\n\tdirection:number;\n\tcolorOffset:number;\n\tcolor:number;\n\tmaterial:any;\n\n\tworkingPlane:string;\n\tworkingDimension:string;\n\n\ttargetBlock:Block;\n\t\n\tconstructor(block:Block)\n\t{\n\t\t// set size and position\n\t\t\n\t\tthis.targetBlock = block;\n\t\t\n\t\tthis.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;\n\t\tthis.workingPlane = this.index % 2 ? 'x' : 'z';\n\t\tthis.workingDimension = this.index % 2 ? 'width' : 'depth';\n\t\t\n\t\t// set the dimensions from the target block, or defaults.\n\t\t\n\t\tthis.dimension.width = this.targetBlock ? this.targetBlock.dimension.width : 10;\n\t\tthis.dimension.height = this.targetBlock ? this.targetBlock.dimension.height : 2;\n\t\tthis.dimension.depth = this.targetBlock ? this.targetBlock.dimension.depth : 10;\n\t\t\n\t\tthis.position.x = this.targetBlock ? this.targetBlock.position.x : 0;\n\t\tthis.position.y = this.dimension.height * this.index;\n\t\tthis.position.z = this.targetBlock ? this.targetBlock.position.z : 0;\n\t\t\n\t\tthis.colorOffset = this.targetBlock ? this.targetBlock.colorOffset : Math.round(Math.random() * 100);\n\t\t\n\t\t// set color\n\t\tif(!this.targetBlock) \n\t\t{\n\t\t\tthis.color = 0x333344;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet offset = this.index + this.colorOffset;\n\t\t\tvar r = Math.sin(0.3 * offset) * 55 + 200;\n\t\t\tvar g = Math.sin(0.3 * offset + 2) * 55 + 200;\n\t\t\tvar b = Math.sin(0.3 * offset + 4) * 55 + 200;\n\t\t\tthis.color = new THREE.Color( r / 255, g / 255, b / 255 );\n\t\t}\n\t\t\n\t\t// state\n\t\t\n\t\tthis.state = this.index > 1 ? this.STATES.ACTIVE : this.STATES.STOPPED;\n\t\t\n\t\t// set direction\n\t\t\n\t\tthis.speed = -0.1 - (this.index * 0.005);\n\t\tif(this.speed < -4) this.speed = -4;\n\t\tthis.direction = this.speed;\n\t\t\n\t\t// create block\n\t\t\n\t\tlet geometry = new THREE.BoxGeometry( this.dimension.width, this.dimension.height, this.dimension.depth);\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation(this.dimension.width/2, this.dimension.height/2, this.dimension.depth/2) );\n\t\tthis.material = new THREE.MeshToonMaterial( {color: this.color, shading: THREE.FlatShading} );\n\t\tthis.mesh = new THREE.Mesh( geometry, this.material );\n\t\tthis.mesh.position.set(this.position.x, this.position.y + (this.state == this.STATES.ACTIVE ? 0 : 0), this.position.z);\n\t\t\n\t\tif(this.state == this.STATES.ACTIVE) \n\t\t{\n\t\t\tthis.position[this.workingPlane] = Math.random() > 0.5 ? -this.MOVE_AMOUNT : this.MOVE_AMOUNT;\n\t\t}\n\t} \n\n\treverseDirection()\n\t{\n\t\tthis.direction = this.direction > 0 ? this.speed : Math.abs(this.speed); \t\n\t}\n\n\tplace():BlockReturn\n\t{\n\t\tthis.state = this.STATES.STOPPED;\n\t\t\n\t\tlet overlap = this.targetBlock.dimension[this.workingDimension] - Math.abs(this.position[this.workingPlane] - this.targetBlock.position[this.workingPlane]);\n\t\t\n\t\tlet blocksToReturn:BlockReturn = {\n\t\t\tplane: this.workingPlane,\n\t\t\tdirection: this.direction\n\t\t};\n\t\t\n\t\tif(this.dimension[this.workingDimension] - overlap < 0.3)\n\t\t{\n\t\t\toverlap = this.dimension[this.workingDimension];\n\t\t\tblocksToReturn.bonus = true;\n\t\t\tthis.position.x = this.targetBlock.position.x;\n\t\t\tthis.position.z = this.targetBlock.position.z;\n\t\t\tthis.dimension.width = this.targetBlock.dimension.width;\n\t\t\tthis.dimension.depth = this.targetBlock.dimension.depth;\n\t\t}\n\t\t\n\t\tif(overlap > 0)\n\t\t{\n\t\t\tlet choppedDimensions = { width: this.dimension.width, height: this.dimension.height, depth: this.dimension.depth };\n\t\t\tchoppedDimensions[this.workingDimension] -= overlap;\n\t\t\tthis.dimension[this.workingDimension] = overlap;\n\t\t\t\t\t\n\t\t\tlet placedGeometry = new THREE.BoxGeometry( this.dimension.width, this.dimension.height, this.dimension.depth);\n\t\t\tplacedGeometry.applyMatrix( new THREE.Matrix4().makeTranslation(this.dimension.width/2, this.dimension.height/2, this.dimension.depth/2) );\n\t\t\tlet placedMesh = new THREE.Mesh( placedGeometry, this.material );\n\t\t\t\n\t\t\tlet choppedGeometry = new THREE.BoxGeometry( choppedDimensions.width, choppedDimensions.height, choppedDimensions.depth);\n\t\t\tchoppedGeometry.applyMatrix( new THREE.Matrix4().makeTranslation(choppedDimensions.width/2, choppedDimensions.height/2, choppedDimensions.depth/2) );\n\t\t\tlet choppedMesh = new THREE.Mesh( choppedGeometry, this.material );\n\t\t\t\n\t\t\tlet choppedPosition = {\n\t\t\t\tx: this.position.x,\n\t\t\t\ty: this.position.y,\n\t\t\t\tz: this.position.z\n\t\t\t}\n\t\t\t\n\t\t\tif(this.position[this.workingPlane] < this.targetBlock.position[this.workingPlane])\n\t\t\t{\n\t\t\t\tthis.position[this.workingPlane] = this.targetBlock.position[this.workingPlane]\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchoppedPosition[this.workingPlane] += overlap;\n\t\t\t}\n\t\t\t\n\t\t\tplacedMesh.position.set(this.position.x, this.position.y, this.position.z);\n\t\t\tchoppedMesh.position.set(choppedPosition.x, choppedPosition.y, choppedPosition.z);\n\t\t\t\n\t\t\tblocksToReturn.placed = placedMesh;\n\t\t\tif(!blocksToReturn.bonus) blocksToReturn.chopped = choppedMesh;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.state = this.STATES.MISSED;\n\t\t}\n\t\t\n\t\tthis.dimension[this.workingDimension] = overlap;\n\n\t\treturn blocksToReturn;\n\t}\n\t\n\ttick()\n\t{\n\t\tif(this.state == this.STATES.ACTIVE)\n\t\t{\n\t\t\tlet value = this.position[this.workingPlane];\n\t\t\tif(value > this.MOVE_AMOUNT || value < -this.MOVE_AMOUNT) this.reverseDirection();\n\t\t\tthis.position[this.workingPlane] += this.direction;\t\n\t\t\tthis.mesh.position[this.workingPlane] = this.position[this.workingPlane];\t\n\t\t}\n\t}\n}\n\nclass Game\n{\n\tconst STATES = {\n\t\t'LOADING': 'loading',\n\t\t'PLAYING': 'playing',\n\t\t'READY': 'ready',\n\t\t'ENDED': 'ended',\n\t\t'RESETTING': 'resetting'\n\t}\n\tblocks:Block[] = [];\n\tstate:string = this.STATES.LOADING;\n\t\n\t// groups\n\n\tnewBlocks:any;\n\tplacedBlocks:any;\n\tchoppedBlocks:any;\n\n\t// UI elements\n\n\tscoreContainer:any;\n\tmainContainer:any;\n\tstartButton:any;\n\tinstructions:any;\n\t\n\tconstructor()\n\t{\n\t\tthis.stage = new Stage();\n\t\t\n\t\tthis.mainContainer = document.getElementById('container');\n\t\tthis.scoreContainer = document.getElementById('score');\n\t\tthis.startButton = document.getElementById('start-button');\n\t\tthis.instructions = document.getElementById('instructions');\n\t\tthis.scoreContainer.innerHTML = '0';\n\t\t\n\t\tthis.newBlocks = new THREE.Group();\n\t\tthis.placedBlocks = new THREE.Group();\n\t\tthis.choppedBlocks = new THREE.Group();\n\t\t\n\t\tthis.stage.add(this.newBlocks);\n\t\tthis.stage.add(this.placedBlocks);\n\t\tthis.stage.add(this.choppedBlocks);\n\t\t\n\t\tthis.addBlock();\n\t\tthis.tick();\n\t\t\n\t\tthis.updateState(this.STATES.READY);\n\t\t\n\t\tdocument.addEventListener('keydown', e =>\n\t\t{\n\t\t\tif(e.keyCode == 32) this.onAction()\n\t\t});\n\t\t\n\t\tdocument.addEventListener('click', e =>\n\t\t{\n\t\t\tthis.onAction();\n\t\t});\t\t\n\t\t\n\t\tdocument.addEventListener('touchstart', e =>\n\t\t{\n\t\t\te.preventDefault();\n\t\t\t// this.onAction();\n\t\t\t\n\t\t\t// ☝️ this triggers after click on android so you\n\t\t\t// insta-lose, will figure it out later.\n\t\t});\n\t}\n\n\tupdateState(newState)\n\t{\n\t\tfor(let key in this.STATES) this.mainContainer.classList.remove(this.STATES[key]);\n\t\tthis.mainContainer.classList.add(newState);\n\t\tthis.state = newState;\n\t}\n\n\tonAction()\n\t{\n\t\tswitch(this.state)\n\t\t{\n\t\t\tcase this.STATES.READY:\n\t\t\t\tthis.startGame();\n\t\t\t\tbreak;\n\t\t\tcase this.STATES.PLAYING:\n\t\t\t\tthis.placeBlock();\n\t\t\t\tbreak;\n\t\t\tcase this.STATES.ENDED:\n\t\t\t\tthis.restartGame();\n\t\t\t\tbreak;\t\n\t\t}\n\t}\n\t\n\tstartGame()\n\t{\n\t\tif(this.state != this.STATES.PLAYING)\n\t\t{\n\t\t\tthis.scoreContainer.innerHTML = '0';\n\t\t\tthis.updateState(this.STATES.PLAYING);\n\t\t\tthis.addBlock();\n\t\t}\n\t}\n\n\trestartGame()\n\t{\n\t\tthis.updateState(this.STATES.RESETTING);\n\t\t\n\t\tlet oldBlocks = this.placedBlocks.children;\n\t\tlet removeSpeed = 0.2;\n\t\tlet delayAmount = 0.02;\n\t\tfor(let i = 0; i < oldBlocks.length; i++)\n\t\t{\n\t\t\tTweenLite.to(oldBlocks[i].scale, removeSpeed, {x: 0, y: 0, z: 0, delay: (oldBlocks.length - i) * delayAmount, ease: Power1.easeIn, onComplete: () => this.placedBlocks.remove(oldBlocks[i])})\n\t\t\tTweenLite.to(oldBlocks[i].rotation, removeSpeed, {y: 0.5, delay: (oldBlocks.length - i) * delayAmount, ease: Power1.easeIn})\n\t\t}\n\t\tlet cameraMoveSpeed = removeSpeed * 2 + (oldBlocks.length * delayAmount);\n\t\tthis.stage.setCamera(2, cameraMoveSpeed);\n\t\t\n\t\tlet countdown = {value: this.blocks.length - 1};\n\t\tTweenLite.to(countdown, cameraMoveSpeed, {value: 0, onUpdate: () => {this.scoreContainer.innerHTML = String(Math.round(countdown.value))}})\n\t\t\n\t\tthis.blocks = this.blocks.slice(0, 1);\n\t\t\n\t\tsetTimeout(() => {\n\t\t\tthis.startGame();\n\t\t}, cameraMoveSpeed * 1000)\n\t\t\n\t}\n\t\n\tplaceBlock()\n\t{\n\t\tlet currentBlock = this.blocks[this.blocks.length - 1];\n\t\tlet newBlocks:BlockReturn = currentBlock.place();\n\t\tthis.newBlocks.remove(currentBlock.mesh);\n\t\tif(newBlocks.placed) this.placedBlocks.add(newBlocks.placed);\n\t\tif(newBlocks.chopped)\n\t\t{\n\t\t\tthis.choppedBlocks.add(newBlocks.chopped);\n\t\t\tlet positionParams = {y: '-=30', ease: Power1.easeIn, onComplete: () => this.choppedBlocks.remove(newBlocks.chopped)}\n\t\t\tlet rotateRandomness = 10;\n\t\t\tlet rotationParams = {\n\t\t\t\tdelay: 0.05,\n\t\t\t\tx: newBlocks.plane == 'z' ? ((Math.random() * rotateRandomness) - (rotateRandomness/2)) : 0.1,\n\t\t\t\tz: newBlocks.plane == 'x' ? ((Math.random() * rotateRandomness) - (rotateRandomness/2)) : 0.1,\n\t\t\t\ty: Math.random() * 0.1,\n\t\t\t};\n\t\t\tif(newBlocks.chopped.position[newBlocks.plane] > newBlocks.placed.position[newBlocks.plane])\n\t\t\t{\n\t\t\t\tpositionParams[newBlocks.plane] = '+=' + (40 * Math.abs(newBlocks.direction));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpositionParams[newBlocks.plane] = '-=' + (40 * Math.abs(newBlocks.direction));\n\t\t\t}\n\t\t\tTweenLite.to(newBlocks.chopped.position, 1, positionParams);\n\t\t\tTweenLite.to(newBlocks.chopped.rotation, 1, rotationParams);\n\t\t\t\n\t\t}\n\t\t\n\t\tthis.addBlock();\n\t}\n\t\n\taddBlock()\n\t{\n\t\tlet lastBlock = this.blocks[this.blocks.length - 1];\n\t\t\n\t\tif(lastBlock && lastBlock.state == lastBlock.STATES.MISSED)\n\t\t{\n\t\t\treturn this.endGame();\n\t\t}\n\t\t\n\t\tthis.scoreContainer.innerHTML = String(this.blocks.length - 1);\n\t\t\n\t\tlet newKidOnTheBlock = new Block(lastBlock);\n\t\tthis.newBlocks.add(newKidOnTheBlock.mesh);\n\t\tthis.blocks.push(newKidOnTheBlock);\n\n\t\tthis.stage.setCamera(this.blocks.length * 2);\n\t\t\n\t\tif(this.blocks.length >= 5) this.instructions.classList.add('hide');\n\t}\n\t\n\tendGame()\n\t{\n\t\tthis.updateState(this.STATES.ENDED);\n\t}\n\n\ttick()\n\t{\n\t\tthis.blocks[this.blocks.length - 1].tick();\n\t\tthis.stage.render();\n\t\trequestAnimationFrame(() => {this.tick()});\n\t}\n}\n\nlet game = new Game();\n</script><style>@import url('https://fonts.googleapis.com/css?family=Comfortaa');\n\n$color-dark: #333344;\n\nhtml, body\n{\n\tmargin: 0;\n\toverflow: hidden;\n\theight: 100%;\n\twidth: 100%;\n\tposition: relative;\n\tfont-family: 'Comfortaa', cursive;\n}\n\n#container\n{\n\twidth: 100%;\n\theight: 100%;\n\t\n\t#score\n\t{\n\t\tposition: absolute;\n\t\ttop: 20px;\n\t\twidth: 100%;\n\t\ttext-align: center;\n\t\tfont-size: 10vh;\n\t\ttransition: transform 0.5s ease;\n\t\tcolor: $color-dark;\n\t\ttransform: translatey(-200px) scale(1);\n\t}\n\n\t#game\n\t{\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tright: 0;\n\t\tbottom: 0;\n\t\tleft: 0;\n\t}\n\t\n\t.game-over\n\t{\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\twidth: 100%;\n\t\theight: 85%;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\t\tjustify-content: center;\n\t\t\n\t\t*\n\t\t{\n\t\t\ttransition: opacity 0.5s ease, transform 0.5s ease;\n\t\t\topacity: 0;\n\t\t\ttransform: translatey(-50px);\n\t\t\tcolor: $color-dark;\n\t\t}\n\t\t\n\t\th2\n\t\t{\n\t\t\tmargin: 0;\n\t\t\tpadding: 0;\n\t\t\tfont-size: 40px;\n\t\t}\n\t}\n\t\n\t.game-ready\n\t{\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\t\tjustify-content: space-around;\n\t\t\n\t\t#start-button\n\t\t{\n\t\t\ttransition: opacity 0.5s ease, transform 0.5s ease;\n\t\t\topacity: 0;\n\t\t\ttransform: translatey(-50px);\n\t\t\t\n\t\t\tborder: 3px solid $color-dark;\n\t\t\tpadding: 10px 20px;\n\t\t\tbackground-color: transparent;\n\t\t\tcolor: $color-dark;\n\t\t\tfont-size: 30px;\n\t\t}\n\t}\n\t\n\t#instructions\n\t{\n\t\tposition: absolute;\n\t\twidth: 100%;\n\t\ttop: 16vh;\n\t\tleft: 0;\n\t\ttext-align: center;\n\t\ttransition: opacity 0.5s ease, transform 0.5s ease;\n\t\t\n\t\topacity: 0;\n\t\t\n\t\t&.hide\n\t\t{\n\t\t\topacity: 0 !important;\n\t\t}\n\t}\n\t\n\t&.playing, &.resetting\n\t{\n\t\t#score\n\t\t{\n\t\t\ttransform: translatey(0px) scale(1);\n\t\t}\n\t}\n\t\n\t&.playing\n\t{\n\t\t#instructions\n\t\t{\n\t\t\topacity: 1;\n\t\t}\n\t}\n\t\n\t&.ready\n\t{\n\t\t\n\t\t\n\t\t.game-ready\n\t\t{\n\t\t\t#start-button\n\t\t\t{\n\t\t\t\topacity: 1;\n\t\t\t\ttransform: translatey(0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t&.ended\n\t{\n\t\t#score\n\t\t{\n\t\t\ttransform: translatey(6vh) scale(1.5);\n\t\t}\n\t\t\n\t\t.game-over\n\t\t{\n\t\t\t*\n\t\t\t{\n\t\t\t\topacity: 1;\n\t\t\t\ttransform: translatey(0);\n\t\t\t}\n\t\t\t\n\t\t\tp\n\t\t\t{\n\t\t\t\ttransition-delay: 0.3s;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n\n</style>"}