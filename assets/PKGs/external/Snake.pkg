{"type":"Game","title":"Snake","desc":"Play Snake on X-Center!","author":"F A R I A T","src":"/assets/media/apps/external/snake.png","id":"SnakeFB4LAZ3YAF","batch":"","content":"<div class=\"container noselect\">\n  <div class=\"wrapper\">\n    <button id=\"replay\">\n      <i class=\"fas fa-play\"></i>\n      RESTART\n    </button>\n    <div id=\"canvas\">\n\n    </div>\n    <div id=\"ui\">\n      <h2>SCORE\n      </h2>\n      <span id=\"score\">00</span>\n    </div>\n  </div>\n  <div id=\"author\">\n    <h1>SNAKE</h1> <span>by Fariat</span>\n  </div>\n</div><script type=\"text/javascript\">\n/** \nThis is a snake game I made with Vanilla Javascript.\nFollow me on twitter @fariatondo\n**/\n\nlet dom_replay = document.querySelector(\"#replay\");\nlet dom_score = document.querySelector(\"#score\");\nlet dom_canvas = document.createElement(\"canvas\");\ndocument.querySelector(\"#canvas\").appendChild(dom_canvas);\nlet CTX = dom_canvas.getContext(\"2d\");\n\nconst W = (dom_canvas.width = 400);\nconst H = (dom_canvas.height = 400);\n\nlet snake,\n  food,\n  currentHue,\n  cells = 20,\n  cellSize,\n  isGameOver = false,\n  tails = [],\n  score = 00,\n  maxScore = window.localStorage.getItem(\"maxScore\") || undefined,\n  particles = [],\n  splashingParticleCount = 20,\n  cellsCount,\n  requestID;\n\nlet helpers = {\n  Vec: class {\n    constructor(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      return this;\n    }\n    mult(v) {\n      if (v instanceof helpers.Vec) {\n        this.x *= v.x;\n        this.y *= v.y;\n        return this;\n      } else {\n        this.x *= v;\n        this.y *= v;\n        return this;\n      }\n    }\n  },\n  isCollision(v1, v2) {\n    return v1.x == v2.x && v1.y == v2.y;\n  },\n  garbageCollector() {\n    for (let i = 0; i < particles.length; i++) {\n      if (particles[i].size <= 0) {\n        particles.splice(i, 1);\n      }\n    }\n  },\n  drawGrid() {\n    CTX.lineWidth = 1.1;\n    CTX.strokeStyle = \"#232332\";\n    CTX.shadowBlur = 0;\n    for (let i = 1; i < cells; i++) {\n      let f = (W / cells) * i;\n      CTX.beginPath();\n      CTX.moveTo(f, 0);\n      CTX.lineTo(f, H);\n      CTX.stroke();\n      CTX.beginPath();\n      CTX.moveTo(0, f);\n      CTX.lineTo(W, f);\n      CTX.stroke();\n      CTX.closePath();\n    }\n  },\n  randHue() {\n    return ~~(Math.random() * 360);\n  },\n  hsl2rgb(hue, saturation, lightness) {\n    if (hue == undefined) {\n      return [0, 0, 0];\n    }\n    let chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;\n    let huePrime = hue / 60;\n    let secondComponent = chroma * (1 - Math.abs((huePrime % 2) - 1));\n\n    huePrime = ~~huePrime;\n    let red;\n    let green;\n    let blue;\n\n    if (huePrime === 0) {\n      red = chroma;\n      green = secondComponent;\n      blue = 0;\n    } else if (huePrime === 1) {\n      red = secondComponent;\n      green = chroma;\n      blue = 0;\n    } else if (huePrime === 2) {\n      red = 0;\n      green = chroma;\n      blue = secondComponent;\n    } else if (huePrime === 3) {\n      red = 0;\n      green = secondComponent;\n      blue = chroma;\n    } else if (huePrime === 4) {\n      red = secondComponent;\n      green = 0;\n      blue = chroma;\n    } else if (huePrime === 5) {\n      red = chroma;\n      green = 0;\n      blue = secondComponent;\n    }\n\n    let lightnessAdjustment = lightness - chroma / 2;\n    red += lightnessAdjustment;\n    green += lightnessAdjustment;\n    blue += lightnessAdjustment;\n\n    return [\n      Math.round(red * 255),\n      Math.round(green * 255),\n      Math.round(blue * 255)\n    ];\n  },\n  lerp(start, end, t) {\n    return start * (1 - t) + end * t;\n  }\n};\n\nlet KEY = {\n  ArrowUp: false,\n  ArrowRight: false,\n  ArrowDown: false,\n  ArrowLeft: false,\n  resetState() {\n    this.ArrowUp = false;\n    this.ArrowRight = false;\n    this.ArrowDown = false;\n    this.ArrowLeft = false;\n  },\n  listen() {\n    addEventListener(\n      \"keydown\",\n      (e) => {\n        if (e.key === \"ArrowUp\" && this.ArrowDown) return;\n        if (e.key === \"ArrowDown\" && this.ArrowUp) return;\n        if (e.key === \"ArrowLeft\" && this.ArrowRight) return;\n        if (e.key === \"ArrowRight\" && this.ArrowLeft) return;\n        this[e.key] = true;\n        Object.keys(this)\n          .filter((f) => f !== e.key && f !== \"listen\" && f !== \"resetState\")\n          .forEach((k) => {\n            this[k] = false;\n          });\n      },\n      false\n    );\n  }\n};\n\nclass Snake {\n  constructor(i, type) {\n    this.pos = new helpers.Vec(W / 2, H / 2);\n    this.dir = new helpers.Vec(0, 0);\n    this.type = type;\n    this.index = i;\n    this.delay = 5;\n    this.size = W / cells;\n    this.color = \"white\";\n    this.history = [];\n    this.total = 1;\n  }\n  draw() {\n    let { x, y } = this.pos;\n    CTX.fillStyle = this.color;\n    CTX.shadowBlur = 20;\n    CTX.shadowColor = \"rgba(255,255,255,.3 )\";\n    CTX.fillRect(x, y, this.size, this.size);\n    CTX.shadowBlur = 0;\n    if (this.total >= 2) {\n      for (let i = 0; i < this.history.length - 1; i++) {\n        let { x, y } = this.history[i];\n        CTX.lineWidth = 1;\n        CTX.fillStyle = \"rgba(225,225,225,1)\";\n        CTX.fillRect(x, y, this.size, this.size);\n      }\n    }\n  }\n  walls() {\n    let { x, y } = this.pos;\n    if (x + cellSize > W) {\n      this.pos.x = 0;\n    }\n    if (y + cellSize > W) {\n      this.pos.y = 0;\n    }\n    if (y < 0) {\n      this.pos.y = H - cellSize;\n    }\n    if (x < 0) {\n      this.pos.x = W - cellSize;\n    }\n  }\n  controlls() {\n    let dir = this.size;\n    if (KEY.ArrowUp) {\n      this.dir = new helpers.Vec(0, -dir);\n    }\n    if (KEY.ArrowDown) {\n      this.dir = new helpers.Vec(0, dir);\n    }\n    if (KEY.ArrowLeft) {\n      this.dir = new helpers.Vec(-dir, 0);\n    }\n    if (KEY.ArrowRight) {\n      this.dir = new helpers.Vec(dir, 0);\n    }\n  }\n  selfCollision() {\n    for (let i = 0; i < this.history.length; i++) {\n      let p = this.history[i];\n      if (helpers.isCollision(this.pos, p)) {\n        isGameOver = true;\n      }\n    }\n  }\n  update() {\n    this.walls();\n    this.draw();\n    this.controlls();\n    if (!this.delay--) {\n      if (helpers.isCollision(this.pos, food.pos)) {\n        incrementScore();\n        particleSplash();\n        food.spawn();\n        this.total++;\n      }\n      this.history[this.total - 1] = new helpers.Vec(this.pos.x, this.pos.y);\n      for (let i = 0; i < this.total - 1; i++) {\n        this.history[i] = this.history[i + 1];\n      }\n      this.pos.add(this.dir);\n      this.delay = 5;\n      this.total > 3 ? this.selfCollision() : null;\n    }\n  }\n}\n\nclass Food {\n  constructor() {\n    this.pos = new helpers.Vec(\n      ~~(Math.random() * cells) * cellSize,\n      ~~(Math.random() * cells) * cellSize\n    );\n    this.color = currentHue = `hsl(${~~(Math.random() * 360)},100%,50%)`;\n    this.size = cellSize;\n  }\n  draw() {\n    let { x, y } = this.pos;\n    CTX.globalCompositeOperation = \"lighter\";\n    CTX.shadowBlur = 20;\n    CTX.shadowColor = this.color;\n    CTX.fillStyle = this.color;\n    CTX.fillRect(x, y, this.size, this.size);\n    CTX.globalCompositeOperation = \"source-over\";\n    CTX.shadowBlur = 0;\n  }\n  spawn() {\n    let randX = ~~(Math.random() * cells) * this.size;\n    let randY = ~~(Math.random() * cells) * this.size;\n    for (let path of snake.history) {\n      if (helpers.isCollision(new helpers.Vec(randX, randY), path)) {\n        return this.spawn();\n      }\n    }\n    this.color = currentHue = `hsl(${helpers.randHue()}, 100%, 50%)`;\n    this.pos = new helpers.Vec(randX, randY);\n  }\n}\n\nclass Particle {\n  constructor(pos, color, size, vel) {\n    this.pos = pos;\n    this.color = color;\n    this.size = Math.abs(size / 2);\n    this.ttl = 0;\n    this.gravity = -0.2;\n    this.vel = vel;\n  }\n  draw() {\n    let { x, y } = this.pos;\n    let hsl = this.color\n      .split(\"\")\n      .filter((l) => l.match(/[^hsl()$% ]/g))\n      .join(\"\")\n      .split(\",\")\n      .map((n) => +n);\n    let [r, g, b] = helpers.hsl2rgb(hsl[0], hsl[1] / 100, hsl[2] / 100);\n    CTX.shadowColor = `rgb(${r},${g},${b},${1})`;\n    CTX.shadowBlur = 0;\n    CTX.globalCompositeOperation = \"lighter\";\n    CTX.fillStyle = `rgb(${r},${g},${b},${1})`;\n    CTX.fillRect(x, y, this.size, this.size);\n    CTX.globalCompositeOperation = \"source-over\";\n  }\n  update() {\n    this.draw();\n    this.size -= 0.3;\n    this.ttl += 1;\n    this.pos.add(this.vel);\n    this.vel.y -= this.gravity;\n  }\n}\n\nfunction incrementScore() {\n  score++;\n  dom_score.innerText = score.toString().padStart(2, \"0\");\n}\n\nfunction particleSplash() {\n  for (let i = 0; i < splashingParticleCount; i++) {\n    let vel = new helpers.Vec(Math.random() * 6 - 3, Math.random() * 6 - 3);\n    let position = new helpers.Vec(food.pos.x, food.pos.y);\n    particles.push(new Particle(position, currentHue, food.size, vel));\n  }\n}\n\nfunction clear() {\n  CTX.clearRect(0, 0, W, H);\n}\n\nfunction initialize() {\n  CTX.imageSmoothingEnabled = false;\n  KEY.listen();\n  cellsCount = cells * cells;\n  cellSize = W / cells;\n  snake = new Snake();\n  food = new Food();\n  dom_replay.addEventListener(\"click\", reset, false);\n  loop();\n}\n\nfunction loop() {\n  clear();\n  if (!isGameOver) {\n    requestID = setTimeout(loop, 1000 / 60);\n    helpers.drawGrid();\n    snake.update();\n    food.draw();\n    for (let p of particles) {\n      p.update();\n    }\n    helpers.garbageCollector();\n  } else {\n    clear();\n    gameOver();\n  }\n}\n\nfunction gameOver() {\n  maxScore ? null : (maxScore = score);\n  score > maxScore ? (maxScore = score) : null;\n  window.localStorage.setItem(\"maxScore\", maxScore);\n  CTX.fillStyle = \"#4cffd7\";\n  CTX.textAlign = \"center\";\n  CTX.font = \"bold 30px Poppins, sans-serif\";\n  CTX.fillText(\"GAME OVER\", W / 2, H / 2);\n  CTX.font = \"15px Poppins, sans-serif\";\n  CTX.fillText(`SCORE   ${score}`, W / 2, H / 2 + 60);\n  CTX.fillText(`MAXSCORE   ${maxScore}`, W / 2, H / 2 + 80);\n}\n\nfunction reset() {\n  dom_score.innerText = \"00\";\n  score = \"00\";\n  snake = new Snake();\n  food.spawn();\n  KEY.resetState();\n  isGameOver = false;\n  clearTimeout(requestID);\n  loop();\n}\n\ninitialize();\n\n</script><style>@font-face {\n  font-family: \"game\";\n  src: url(\"https://fonts.googleapis.com/css2?family=Poppins:wght@500;800&display=swap\");\n}\n* {\n  padding: 0;\n  margin: 0;\n  box-sizing: border-box;\n}\nbutton:focus {\n  outline: 0;\n}\n\nhtml,\nbody {\n  height: 100%;\n  font-family: \"Poppins\", sans-serif;\n  color: #6e7888;\n}\nbody {\n  background-color: #222738;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  color: #6e7888;\n}\ncanvas {\n  background-color: #181825;\n}\n.container {\n  display: flex;\n  width: 100%;\n  height: 100%;\n  flex-flow: column wrap;\n  justify-content: center;\n  align-items: center;\n}\n#ui {\n  display: flex;\n  align-items: center;\n  font-size: 10px;\n  flex-flow: column;\n  margin-left: 10px;\n}\nh2 {\n  font-weight: 200;\n  transform: rotate(270deg);\n}\n#score {\n  margin-top: 20px;\n  font-size: 30px;\n  font-weight: 800;\n}\n.noselect {\n  user-select: none;\n}\n#replay {\n  font-size: 10px;\n  padding: 10px 20px;\n  background: #6e7888;\n  border: none;\n  color: #222738;\n  border-radius: 20px;\n  font-weight: 800;\n  transform: rotate(270deg);\n  cursor: pointer;\n  transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n#replay:hover {\n  background: #a6aab5;\n  background: #4cffd7;\n  transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1);\n}\n#replay svg {\n  margin-right: 8px;\n}\n@media (max-width: 600px) {\n  #replay {\n    margin-bottom: 20px;\n  }\n  #replay,\n  h2 {\n    transform: rotate(0deg);\n  }\n  #ui {\n    flex-flow: row wrap;\n    margin-bottom: 20px;\n  }\n  #score {\n    margin-top: 0;\n    margin-left: 20px;\n  }\n  .container {\n    flex-flow: column wrap;\n  }\n}\n#author {\n  width: 100%;\n  bottom: 40px;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  font-weight: 600;\n  color: inherit;\n  text-transform: uppercase;\n  padding-left: 35px;\n}\n#author span {\n  font-size: 10px;\n  margin-left: 20px;\n  color: inherit;\n  letter-spacing: 4px;\n}\n#author h1 {\n  font-size: 25px;\n}\n.wrapper {\n  display: flex;\n  flex-flow: row wrap;\n  justify-content: center;\n  align-items: center;\n  margin-bottom: 20px;\n}\n</style>"}