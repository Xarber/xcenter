{"type":"Game","title":"Menja","desc":"Menja is a Web Game based on vanilla js","author":"Caleb Miller","src":"data:image/png;base64,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","id":"MenjaARQV8U1A84","batch":"","content":"<!-- Game canvas -->\n<canvas id=\"c\"></canvas>\n\n<!-- Gameplay HUD -->\n<div class=\"hud\">\n\t<div class=\"hud__score\">\n\t\t<div class=\"score-lbl\"></div>\n\t\t<div class=\"cube-count-lbl\"></div>\n\t</div>\n\t<div class=\"pause-btn\"><div></div></div>\n\t<div class=\"slowmo\">\n\t\t<div class=\"slowmo__bar\"></div>\n\t</div>\n</div>\n\n<!-- Menu System -->\n<div class=\"menus\">\n\t<div class=\"menu menu--main\">\n\t\t<h1>MENJA</h1>\n\t\t<button type=\"button\" class=\"play-normal-btn\">PLAY GAME</button>\n\t\t<button type=\"button\" class=\"play-casual-btn\">CASUAL MODE</button>\n\t\t<div class=\"credits\">An 8kB game by <a href=\"https://cmiller.tech\">Caleb Miller</a></div>\n\t</div>\n\t<div class=\"menu menu--pause\">\n\t\t<h1>Paused</h1>\n\t\t<button type=\"button\" class=\"resume-btn\">RESUME GAME</button>\n\t\t<button type=\"button\" class=\"menu-btn--pause\">MAIN MENU</button>\n\t</div>\n\t<div class=\"menu menu--score\">\n\t\t<h1>Game Over</h1>\n\t\t<h2>Your Score:</h2>\n\t\t<div class=\"final-score-lbl\"></div>\n\t\t<div class=\"high-score-lbl\"></div>\n\t\t<button type=\"button\" class=\"play-again-btn\">PLAY AGAIN</button>\n\t\t<button type=\"button\" class=\"menu-btn--score\">MAIN MENU</button>\n\t</div>\n</div>\n<script type=\"text/javascript\">\n// globalConfig.js\n// ============================================================================\n// ============================================================================\n\n// Provides global variables used by the entire program.\n// Most of this should be configuration.\n\n// Timing multiplier for entire game engine.\nlet gameSpeed = 1;\n\n// Colors\nconst BLUE =   { r: 0x67, g: 0xd7, b: 0xf0 };\nconst GREEN =  { r: 0xa6, g: 0xe0, b: 0x2c };\nconst PINK =   { r: 0xfa, g: 0x24, b: 0x73 };\nconst ORANGE = { r: 0xfe, g: 0x95, b: 0x22 };\nconst allColors = [BLUE, GREEN, PINK, ORANGE];\n\n// Gameplay\nconst getSpawnDelay = () => {\n\tconst spawnDelayMax = 1400;\n\tconst spawnDelayMin = 550;\n\tconst spawnDelay = spawnDelayMax - state.game.cubeCount * 3.1;\n\treturn Math.max(spawnDelay, spawnDelayMin);\n}\nconst doubleStrongEnableScore = 2000;\n// Number of cubes that must be smashed before activating a feature.\nconst slowmoThreshold = 10;\nconst strongThreshold = 25;\nconst spinnerThreshold = 25;\n\n// Interaction state\nlet pointerIsDown = false;\n// The last known position of the primary pointer in screen coordinates.`\nlet pointerScreen = { x: 0, y: 0 };\n// Same as `pointerScreen`, but converted to scene coordinates in rAF.\nlet pointerScene = { x: 0, y: 0 };\n// Minimum speed of pointer before \"hits\" are counted.\nconst minPointerSpeed = 60;\n// The hit speed affects the direction the target post-hit. This number dampens that force.\nconst hitDampening = 0.1;\n// Backboard receives shadows and is the farthest negative Z position of entities.\nconst backboardZ = -400;\nconst shadowColor = '#262e36';\n// How much air drag is applied to standard objects\nconst airDrag = 0.022;\nconst gravity = 0.3;\n// Spark config\nconst sparkColor = 'rgba(170,221,255,.9)';\nconst sparkThickness = 2.2;\nconst airDragSpark = 0.1;\n// Track pointer positions to show trail\nconst touchTrailColor = 'rgba(170,221,255,.62)';\nconst touchTrailThickness = 7;\nconst touchPointLife = 120;\nconst touchPoints = [];\n// Size of in-game targets. This affects rendered size and hit area.\nconst targetRadius = 40;\nconst targetHitRadius = 50;\nconst makeTargetGlueColor = target => {\n\t// const alpha = (target.health - 1) / (target.maxHealth - 1);\n\t// return `rgba(170,221,255,${alpha.toFixed(3)})`;\n\treturn 'rgb(170,221,255)';\n};\n// Size of target fragments\nconst fragRadius = targetRadius / 3;\n\n\n\n// Game canvas element needed in setup.js and interaction.js\nconst canvas = document.querySelector('#c');\n\n// 3D camera config\n// Affects perspective\nconst cameraDistance = 900;\n// Does not affect perspective\nconst sceneScale = 1;\n// Objects that get too close to the camera will be faded out to transparent over this range.\n// const cameraFadeStartZ = 0.8*cameraDistance - 6*targetRadius;\nconst cameraFadeStartZ = 0.45*cameraDistance;\nconst cameraFadeEndZ = 0.65*cameraDistance;\nconst cameraFadeRange = cameraFadeEndZ - cameraFadeStartZ;\n\n// Globals used to accumlate all vertices/polygons in each frame\nconst allVertices = [];\nconst allPolys = [];\nconst allShadowVertices = [];\nconst allShadowPolys = [];\n\n\n\n\n// state.js\n// ============================================================================\n// ============================================================================\n\n///////////\n// Enums //\n///////////\n\n// Game Modes\nconst GAME_MODE_RANKED = Symbol('GAME_MODE_RANKED');\nconst GAME_MODE_CASUAL = Symbol('GAME_MODE_CASUAL');\n\n// Available Menus\nconst MENU_MAIN = Symbol('MENU_MAIN');\nconst MENU_PAUSE = Symbol('MENU_PAUSE');\nconst MENU_SCORE = Symbol('MENU_SCORE');\n\n\n\n//////////////////\n// Global State //\n//////////////////\n\nconst state = {\n\tgame: {\n\t\tmode: GAME_MODE_RANKED,\n\t\t// Run time of current game.\n\t\ttime: 0,\n\t\t// Player score.\n\t\tscore: 0,\n\t\t// Total number of cubes smashed in game.\n\t\tcubeCount: 0\n\t},\n\tmenus: {\n\t\t// Set to `null` to hide all menus\n\t\tactive: MENU_MAIN\n\t}\n};\n\n\n////////////////////////////\n// Global State Selectors //\n////////////////////////////\n\nconst isInGame = () => !state.menus.active;\nconst isMenuVisible = () => !!state.menus.active;\nconst isCasualGame = () => state.game.mode === GAME_MODE_CASUAL;\nconst isPaused = () => state.menus.active === MENU_PAUSE;\n\n\n///////////////////\n// Local Storage //\n///////////////////\n\nconst highScoreKey = '__menja__highScore';\nconst getHighScore = () => {\n\tconst raw = localStorage.getItem(highScoreKey);\n\treturn raw ? parseInt(raw, 10) : 0;\n};\n\nlet _lastHighscore = getHighScore();\nconst setHighScore = score => {\n\t_lastHighscore = getHighScore();\n\tlocalStorage.setItem(highScoreKey, String(score));\n};\n\nconst isNewHighScore = () => state.game.score > _lastHighscore;\n\n\n\n\n// utils.js\n// ============================================================================\n// ============================================================================\n\n\nconst invariant = (condition, message) => {\n\tif (!condition) throw new Error(message);\n};\n\n\n/////////\n// DOM //\n/////////\n\nconst $ = selector => document.querySelector(selector);\nconst handleClick = (element, handler) => element.addEventListener('click', handler);\nconst handlePointerDown = (element, handler) => {\n\telement.addEventListener('touchstart', handler);\n\telement.addEventListener('mousedown', handler);\n};\n\n\n\n////////////////////////\n// Formatting Helpers //\n////////////////////////\n\n// Converts a number into a formatted string with thousand separators.\nconst formatNumber = num => num.toLocaleString();\n\n\n\n////////////////////\n// Math Constants //\n////////////////////\n\nconst PI = Math.PI;\nconst TAU = Math.PI * 2;\nconst ETA = Math.PI * 0.5;\n\n\n\n//////////////////\n// Math Helpers //\n//////////////////\n\n// Clamps a number between min and max values (inclusive)\nconst clamp = (num, min, max) => Math.min(Math.max(num, min), max);\n\n// Linearly interpolate between numbers a and b by a specific amount.\n// mix >= 0 && mix <= 1\nconst lerp = (a, b, mix) => (b - a) * mix + a;\n\n\n\n\n////////////////////\n// Random Helpers //\n////////////////////\n\n// Generates a random number between min (inclusive) and max (exclusive)\nconst random = (min, max) => Math.random() * (max - min) + min;\n\n// Generates a random integer between and possibly including min and max values\nconst randomInt = (min, max) => ((Math.random() * (max - min + 1)) | 0) + min;\n\n// Returns a random element from an array\nconst pickOne = arr => arr[Math.random() * arr.length | 0];\n\n\n\n\n///////////////////\n// Color Helpers //\n///////////////////\n\n// Converts an { r, g, b } color object to a 6-digit hex code.\nconst colorToHex = color => {\n\treturn '#' +\n\t\t(color.r | 0).toString(16).padStart(2, '0') +\n\t\t(color.g | 0).toString(16).padStart(2, '0') +\n\t\t(color.b | 0).toString(16).padStart(2, '0');\n};\n\n// Operates on an { r, g, b } color object.\n// Returns string hex code.\n// `lightness` must range from 0 to 1. 0 is pure black, 1 is pure white.\nconst shadeColor = (color, lightness) => {\n\tlet other, mix;\n\tif (lightness < 0.5) {\n\t\tother = 0;\n\t\tmix = 1 - (lightness * 2);\n\t} else {\n\t\tother = 255;\n\t\tmix = lightness * 2 - 1;\n\t}\n\treturn '#' +\n\t\t(lerp(color.r, other, mix) | 0).toString(16).padStart(2, '0') +\n\t\t(lerp(color.g, other, mix) | 0).toString(16).padStart(2, '0') +\n\t\t(lerp(color.b, other, mix) | 0).toString(16).padStart(2, '0');\n};\n\n\n\n\n\n////////////////////\n// Timing Helpers //\n////////////////////\n\nconst _allCooldowns = [];\n\nconst makeCooldown = (rechargeTime, units=1) => {\n\tlet timeRemaining = 0;\n\tlet lastTime = 0;\n\n\tconst initialOptions = { rechargeTime, units };\n\n\tconst updateTime = () => {\n\t\tconst now = state.game.time;\n\t\t// Reset time remaining if time goes backwards.\n\t\tif (now < lastTime) {\n\t\t\ttimeRemaining = 0;\n\t\t} else {\n\t\t\t// update...\n\t\t\ttimeRemaining -= now-lastTime;\n\t\t\tif (timeRemaining < 0) timeRemaining = 0;\n\t\t}\n\t\tlastTime = now;\n\t};\n\n\tconst canUse = () => {\n\t\tupdateTime();\n\t\treturn timeRemaining <= (rechargeTime * (units-1));\n\t};\n\n\tconst cooldown = {\n\t\tcanUse,\n\t\tuseIfAble() {\n\t\t\tconst usable = canUse();\n\t\t\tif (usable) timeRemaining += rechargeTime;\n\t\t\treturn usable;\n\t\t},\n\t\tmutate(options) {\n\t\t\tif (options.rechargeTime) {\n\t\t\t\t// Apply recharge time delta so change takes effect immediately.\n\t\t\t\ttimeRemaining -= rechargeTime-options.rechargeTime;\n\t\t\t\tif (timeRemaining < 0) timeRemaining = 0;\n\t\t\t\trechargeTime = options.rechargeTime;\n\t\t\t}\n\t\t\tif (options.units) units = options.units;\n\t\t},\n\t\treset() {\n\t\t\ttimeRemaining = 0;\n\t\t\tlastTime = 0;\n\t\t\tthis.mutate(initialOptions);\n\t\t}\n\t};\n\n\t_allCooldowns.push(cooldown);\n\n\treturn cooldown;\n};\n\nconst resetAllCooldowns = () => _allCooldowns.forEach(cooldown => cooldown.reset());\n\nconst makeSpawner = ({ chance, cooldownPerSpawn, maxSpawns }) => {\n\tconst cooldown = makeCooldown(cooldownPerSpawn, maxSpawns);\n\treturn {\n\t\tshouldSpawn() {\n\t\t\treturn Math.random() <= chance && cooldown.useIfAble();\n\t\t},\n\t\tmutate(options) {\n\t\t\tif (options.chance) chance = options.chance;\n\t\t\tcooldown.mutate({\n\t\t\t\trechargeTime: options.cooldownPerSpawn,\n\t\t\t\tunits: options.maxSpawns\n\t\t\t});\n\t\t}\n\t};\n};\n\n\n\n\n////////////////////\n// Vector Helpers //\n////////////////////\n\nconst normalize = v => {\n\tconst mag = Math.hypot(v.x, v.y, v.z);\n\treturn {\n\t\tx: v.x / mag,\n\t\ty: v.y / mag,\n\t\tz: v.z / mag\n\t};\n}\n\n// Curried math helpers\nconst add = a => b => a + b;\n// Curried vector helpers\nconst scaleVector = scale => vector => {\n\tvector.x *= scale;\n\tvector.y *= scale;\n\tvector.z *= scale;\n};\n\n\n\n\n\n\n\n\n////////////////\n// 3D Helpers //\n////////////////\n\n// Clone array and all vertices.\nfunction cloneVertices(vertices) {\n\treturn vertices.map(v => ({ x: v.x, y: v.y, z: v.z }));\n}\n\n// Copy vertex data from one array into another.\n// Arrays must be the same length.\nfunction copyVerticesTo(arr1, arr2) {\n\tconst len = arr1.length;\n\tfor (let i=0; i<len; i++) {\n\t\tconst v1 = arr1[i];\n\t\tconst v2 = arr2[i];\n\t\tv2.x = v1.x;\n\t\tv2.y = v1.y;\n\t\tv2.z = v1.z;\n\t}\n}\n\n// Compute triangle midpoint.\n// Mutates `middle` property of given `poly`.\nfunction computeTriMiddle(poly) {\n\tconst v = poly.vertices;\n\tpoly.middle.x = (v[0].x + v[1].x + v[2].x) / 3;\n\tpoly.middle.y = (v[0].y + v[1].y + v[2].y) / 3;\n\tpoly.middle.z = (v[0].z + v[1].z + v[2].z) / 3;\n}\n\n// Compute quad midpoint.\n// Mutates `middle` property of given `poly`.\nfunction computeQuadMiddle(poly) {\n\tconst v = poly.vertices;\n\tpoly.middle.x = (v[0].x + v[1].x + v[2].x + v[3].x) / 4;\n\tpoly.middle.y = (v[0].y + v[1].y + v[2].y + v[3].y) / 4;\n\tpoly.middle.z = (v[0].z + v[1].z + v[2].z + v[3].z) / 4;\n}\n\nfunction computePolyMiddle(poly) {\n\tif (poly.vertices.length === 3) {\n\t\tcomputeTriMiddle(poly);\n\t} else {\n\t\tcomputeQuadMiddle(poly);\n\t}\n}\n\n// Compute distance from any polygon (tri or quad) midpoint to camera.\n// Sets `depth` property of given `poly`.\n// Also triggers midpoint calculation, which mutates `middle` property of `poly`.\nfunction computePolyDepth(poly) {\n\tcomputePolyMiddle(poly);\n\tconst dX = poly.middle.x;\n\tconst dY = poly.middle.y;\n\tconst dZ = poly.middle.z - cameraDistance;\n\tpoly.depth = Math.hypot(dX, dY, dZ);\n}\n\n// Compute normal of any polygon. Uses normalized vector cross product.\n// Mutates `normalName` property of given `poly`.\nfunction computePolyNormal(poly, normalName) {\n\t// Store quick refs to vertices\n\tconst v1 = poly.vertices[0];\n\tconst v2 = poly.vertices[1];\n\tconst v3 = poly.vertices[2];\n\t// Calculate difference of vertices, following winding order.\n\tconst ax = v1.x - v2.x;\n\tconst ay = v1.y - v2.y;\n\tconst az = v1.z - v2.z;\n\tconst bx = v1.x - v3.x;\n\tconst by = v1.y - v3.y;\n\tconst bz = v1.z - v3.z;\n\t// Cross product\n\tconst nx = ay*bz - az*by;\n\tconst ny = az*bx - ax*bz;\n\tconst nz = ax*by - ay*bx;\n\t// Compute magnitude of normal and normalize\n\tconst mag = Math.hypot(nx, ny, nz);\n\tconst polyNormal = poly[normalName];\n\tpolyNormal.x = nx / mag;\n\tpolyNormal.y = ny / mag;\n\tpolyNormal.z = nz / mag;\n}\n\n// Apply translation/rotation/scale to all given vertices.\n// If `vertices` and `target` are the same array, the vertices will be mutated in place.\n// If `vertices` and `target` are different arrays, `vertices` will not be touched, instead the\n// transformed values from `vertices` will be written to `target` array.\nfunction transformVertices(vertices, target, tX, tY, tZ, rX, rY, rZ, sX, sY, sZ) {\n\t// Matrix multiplcation constants only need calculated once for all vertices.\n\tconst sinX = Math.sin(rX);\n\tconst cosX = Math.cos(rX);\n\tconst sinY = Math.sin(rY);\n\tconst cosY = Math.cos(rY);\n\tconst sinZ = Math.sin(rZ);\n\tconst cosZ = Math.cos(rZ);\n\n\t// Using forEach() like map(), but with a (recycled) target array.\n\tvertices.forEach((v, i) => {\n\t\tconst targetVertex = target[i];\n\t\t// X axis rotation\n\t\tconst x1 = v.x;\n\t\tconst y1 = v.z*sinX + v.y*cosX;\n\t\tconst z1 = v.z*cosX - v.y*sinX;\n\t\t// Y axis rotation\n\t\tconst x2 = x1*cosY - z1*sinY;\n\t\tconst y2 = y1;\n\t\tconst z2 = x1*sinY + z1*cosY;\n\t\t// Z axis rotation\n\t\tconst x3 = x2*cosZ - y2*sinZ;\n\t\tconst y3 = x2*sinZ + y2*cosZ;\n\t\tconst z3 = z2;\n\n\t\t// Scale, Translate, and set the transform.\n\t\ttargetVertex.x = x3 * sX + tX;\n\t\ttargetVertex.y = y3 * sY + tY;\n\t\ttargetVertex.z = z3 * sZ + tZ;\n\t});\n}\n\n// 3D projection on a single vertex.\n// Directly mutates the vertex.\nconst projectVertex = v => {\n\tconst focalLength = cameraDistance * sceneScale;\n\tconst depth = focalLength / (cameraDistance - v.z);\n\tv.x = v.x * depth;\n\tv.y = v.y * depth;\n};\n\n// 3D projection on a single vertex.\n// Mutates a secondary target vertex.\nconst projectVertexTo = (v, target) => {\n\tconst focalLength = cameraDistance * sceneScale;\n\tconst depth = focalLength / (cameraDistance - v.z);\n\ttarget.x = v.x * depth;\n\ttarget.y = v.y * depth;\n};\n\n\n\n\n\n// PERF.js\n// ============================================================================\n// ============================================================================\n\n// Dummy no-op functions.\n// I use these in a special build for custom performance profiling.\nconst PERF_START = () => {};\nconst PERF_END = () => {};\nconst PERF_UPDATE = () => {};\n\n\n\n\n// 3dModels.js\n// ============================================================================\n// ============================================================================\n\n// Define models once. The origin is the center of the model.\n\n// A simple cube, 8 vertices, 6 quads.\n// Defaults to an edge length of 2 units, can be influenced with `scale`.\nfunction makeCubeModel({ scale=1 }) {\n\treturn {\n\t\tvertices: [\n\t\t\t// top\n\t\t\t{ x: -scale, y: -scale, z: scale },\n\t\t\t{ x:  scale, y: -scale, z: scale },\n\t\t\t{ x:  scale, y:  scale, z: scale },\n\t\t\t{ x: -scale, y:  scale, z: scale },\n\t\t\t// bottom\n\t\t\t{ x: -scale, y: -scale, z: -scale },\n\t\t\t{ x:  scale, y: -scale, z: -scale },\n\t\t\t{ x:  scale, y:  scale, z: -scale },\n\t\t\t{ x: -scale, y:  scale, z: -scale }\n\t\t],\n\t\tpolys: [\n\t\t\t// z = 1\n\t\t\t{ vIndexes: [0, 1, 2, 3] },\n\t\t\t// z = -1\n\t\t\t{ vIndexes: [7, 6, 5, 4] },\n\t\t\t// y = 1\n\t\t\t{ vIndexes: [3, 2, 6, 7] },\n\t\t\t// y = -1\n\t\t\t{ vIndexes: [4, 5, 1, 0] },\n\t\t\t// x = 1\n\t\t\t{ vIndexes: [5, 6, 2, 1] },\n\t\t\t// x = -1\n\t\t\t{ vIndexes: [0, 3, 7, 4] }\n\t\t]\n\t};\n}\n\n// Not very optimized - lots of duplicate vertices are generated.\nfunction makeRecursiveCubeModel({ recursionLevel, splitFn, color, scale=1 }) {\n\tconst getScaleAtLevel = level => 1 / (3 ** level);\n\n\t// We can model level 0 manually. It's just a single, centered, cube.\n\tlet cubeOrigins = [{ x: 0, y: 0, z: 0 }];\n\n\t// Recursively replace cubes with smaller cubes.\n\tfor (let i=1; i<=recursionLevel; i++) {\n\t\tconst scale = getScaleAtLevel(i) * 2;\n\t\tconst cubeOrigins2 = [];\n\t\tcubeOrigins.forEach(origin => {\n\t\t\tcubeOrigins2.push(...splitFn(origin, scale));\n\t\t});\n\t\tcubeOrigins = cubeOrigins2;\n\t}\n\n\tconst finalModel = { vertices: [], polys: [] };\n\n\t// Generate single cube model and scale it.\n\tconst cubeModel = makeCubeModel({ scale: 1 });\n\tcubeModel.vertices.forEach(scaleVector(getScaleAtLevel(recursionLevel)));\n\n\t// Compute the max distance x, y, or z origin values will be.\n\t// Same result as `Math.max(...cubeOrigins.map(o => o.x))`, but much faster.\n\tconst maxComponent = getScaleAtLevel(recursionLevel) * (3 ** recursionLevel - 1);\n\n\t// Place cube geometry at each origin.\n\tcubeOrigins.forEach((origin, cubeIndex) => {\n\t\t// To compute occlusion (shading), find origin component with greatest\n\t\t// magnitude and normalize it relative to `maxComponent`.\n\t\tconst occlusion = Math.max(\n\t\t\tMath.abs(origin.x),\n\t\t\tMath.abs(origin.y),\n\t\t\tMath.abs(origin.z)\n\t\t) / maxComponent;\n\t\t// At lower iterations, occlusion looks better lightened up a bit.\n\t\tconst occlusionLighter = recursionLevel > 2\n\t\t\t? occlusion\n\t\t\t: (occlusion + 0.8) / 1.8;\n\t\t// Clone, translate vertices to origin, and apply scale\n\t\tfinalModel.vertices.push(\n\t\t\t...cubeModel.vertices.map(v => ({\n\t\t\t\tx: (v.x + origin.x) * scale,\n\t\t\t\ty: (v.y + origin.y) * scale,\n\t\t\t\tz: (v.z + origin.z) * scale\n\t\t\t}))\n\t\t);\n\t\t// Clone polys, shift referenced vertex indexes, and compute color.\n\t\tfinalModel.polys.push(\n\t\t\t...cubeModel.polys.map(poly => ({\n\t\t\t\tvIndexes: poly.vIndexes.map(add(cubeIndex * 8))\n\t\t\t}))\n\t\t);\n\t});\n\n\treturn finalModel;\n}\n\n\n// o: Vector3D - Position of cube's origin (center).\n// s: Vector3D - Determines size of menger sponge.\nfunction mengerSpongeSplit(o, s) {\n\treturn [\n\t\t// Top\n\t\t{ x: o.x + s, y: o.y - s, z: o.z + s },\n\t\t{ x: o.x + s, y: o.y - s, z: o.z + 0 },\n\t\t{ x: o.x + s, y: o.y - s, z: o.z - s },\n\t\t{ x: o.x + 0, y: o.y - s, z: o.z + s },\n\t\t{ x: o.x + 0, y: o.y - s, z: o.z - s },\n\t\t{ x: o.x - s, y: o.y - s, z: o.z + s },\n\t\t{ x: o.x - s, y: o.y - s, z: o.z + 0 },\n\t\t{ x: o.x - s, y: o.y - s, z: o.z - s },\n\t\t// Bottom\n\t\t{ x: o.x + s, y: o.y + s, z: o.z + s },\n\t\t{ x: o.x + s, y: o.y + s, z: o.z + 0 },\n\t\t{ x: o.x + s, y: o.y + s, z: o.z - s },\n\t\t{ x: o.x + 0, y: o.y + s, z: o.z + s },\n\t\t{ x: o.x + 0, y: o.y + s, z: o.z - s },\n\t\t{ x: o.x - s, y: o.y + s, z: o.z + s },\n\t\t{ x: o.x - s, y: o.y + s, z: o.z + 0 },\n\t\t{ x: o.x - s, y: o.y + s, z: o.z - s },\n\t\t// Middle\n\t\t{ x: o.x + s, y: o.y + 0, z: o.z + s },\n\t\t{ x: o.x + s, y: o.y + 0, z: o.z - s },\n\t\t{ x: o.x - s, y: o.y + 0, z: o.z + s },\n\t\t{ x: o.x - s, y: o.y + 0, z: o.z - s }\n\t];\n}\n\n\n\n// Helper to optimize models by merging duplicate vertices within a threshold,\n// and removing all polys that share the same vertices.\n// Directly mutates the model.\nfunction optimizeModel(model, threshold=0.0001) {\n\tconst { vertices, polys } = model;\n\n\tconst compareVertices = (v1, v2) => (\n\t\tMath.abs(v1.x - v2.x) < threshold &&\n\t\tMath.abs(v1.y - v2.y) < threshold &&\n\t\tMath.abs(v1.z - v2.z) < threshold\n\t);\n\n\tconst comparePolys = (p1, p2) => {\n\t\tconst v1 = p1.vIndexes;\n\t\tconst v2 = p2.vIndexes;\n\t\treturn (\n\t\t\t(\n\t\t\t\tv1[0] === v2[0] ||\n\t\t\t\tv1[0] === v2[1] ||\n\t\t\t\tv1[0] === v2[2] ||\n\t\t\t\tv1[0] === v2[3]\n\t\t\t) && (\n\t\t\t\tv1[1] === v2[0] ||\n\t\t\t\tv1[1] === v2[1] ||\n\t\t\t\tv1[1] === v2[2] ||\n\t\t\t\tv1[1] === v2[3]\n\t\t\t) && (\n\t\t\t\tv1[2] === v2[0] ||\n\t\t\t\tv1[2] === v2[1] ||\n\t\t\t\tv1[2] === v2[2] ||\n\t\t\t\tv1[2] === v2[3]\n\t\t\t) && (\n\t\t\t\tv1[3] === v2[0] ||\n\t\t\t\tv1[3] === v2[1] ||\n\t\t\t\tv1[3] === v2[2] ||\n\t\t\t\tv1[3] === v2[3]\n\t\t\t)\n\t\t);\n\t};\n\n\n\tvertices.forEach((v, i) => {\n\t\tv.originalIndexes = [i];\n\t});\n\n\tfor (let i=vertices.length-1; i>=0; i--) {\n\t\tfor (let ii=i-1; ii>=0; ii--) {\n\t\t\tconst v1 = vertices[i];\n\t\t\tconst v2 = vertices[ii];\n\t\t\tif (compareVertices(v1, v2)) {\n\t\t\t\tvertices.splice(i, 1);\n\t\t\t\tv2.originalIndexes.push(...v1.originalIndexes);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvertices.forEach((v, i) => {\n\t\tpolys.forEach(p => {\n\t\t\tp.vIndexes.forEach((vi, ii, arr) => {\n\t\t\t\tconst vo = v.originalIndexes;\n\t\t\t\tif (vo.includes(vi)) {\n\t\t\t\t\tarr[ii] = i;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n\n\tpolys.forEach(p => {\n\t\tconst vi = p.vIndexes;\n\t\tp.sum = vi[0] + vi[1] + vi[2] + vi[3];\n\t});\n\tpolys.sort((a, b) => b.sum - a.sum);\n\n\t// Assumptions:\n\t// 1. Each poly will either have no duplicates or 1 duplicate.\n\t// 2. If two polys are equal, they are both hidden (two cubes touching),\n\t//    therefore both can be removed.\n\tfor (let i=polys.length-1; i>=0; i--) {\n\t\tfor (let ii=i-1; ii>=0; ii--) {\n\t\t\tconst p1 = polys[i];\n\t\t\tconst p2 = polys[ii];\n\t\t\tif (p1.sum !== p2.sum) break;\n\t\t\tif (comparePolys(p1, p2)) {\n\t\t\t\tpolys.splice(i, 1);\n\t\t\t\tpolys.splice(ii, 1);\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn model;\n}\n\n\n\n\n\n// Entity.js\n// ============================================================================\n// ============================================================================\n\nclass Entity {\n\tconstructor({ model, color, wireframe=false }) {\n\t\tconst vertices = cloneVertices(model.vertices);\n\t\tconst shadowVertices = cloneVertices(model.vertices);\n\t\tconst colorHex = colorToHex(color);\n\t\tconst darkColorHex = shadeColor(color, 0.4);\n\n\t\tconst polys = model.polys.map(p => ({\n\t\t\tvertices: p.vIndexes.map(vIndex => vertices[vIndex]),\n\t\t\tcolor: color, // custom rgb color object\n\t\t\twireframe: wireframe,\n\t\t\tstrokeWidth: wireframe ? 2 : 0, // Set to non-zero value to draw stroke\n\t\t\tstrokeColor: colorHex, // must be a CSS color string\n\t\t\tstrokeColorDark: darkColorHex, // must be a CSS color string\n\t\t\tdepth: 0,\n\t\t\tmiddle: { x: 0, y: 0, z: 0 },\n\t\t\tnormalWorld: { x: 0, y: 0, z: 0 },\n\t\t\tnormalCamera: { x: 0, y: 0, z: 0 }\n\t\t}));\n\n\t\tconst shadowPolys = model.polys.map(p => ({\n\t\t\tvertices: p.vIndexes.map(vIndex => shadowVertices[vIndex]),\n\t\t\twireframe: wireframe,\n\t\t\tnormalWorld: { x: 0, y: 0, z: 0 }\n\t\t}));\n\n\t\tthis.projected = {}; // Will store 2D projected data\n\t\tthis.model = model;\n\t\tthis.vertices = vertices;\n\t\tthis.polys = polys;\n\t\tthis.shadowVertices = shadowVertices;\n\t\tthis.shadowPolys = shadowPolys;\n\t\tthis.reset();\n\t}\n\n\t// Better names: resetEntity, resetTransform, resetEntityTransform\n\treset() {\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t\tthis.z = 0;\n\t\tthis.xD = 0;\n\t\tthis.yD = 0;\n\t\tthis.zD = 0;\n\n\t\tthis.rotateX = 0;\n\t\tthis.rotateY = 0;\n\t\tthis.rotateZ = 0;\n\t\tthis.rotateXD = 0;\n\t\tthis.rotateYD = 0;\n\t\tthis.rotateZD = 0;\n\n\t\tthis.scaleX = 1;\n\t\tthis.scaleY = 1;\n\t\tthis.scaleZ = 1;\n\n\t\tthis.projected.x = 0;\n\t\tthis.projected.y = 0;\n\t}\n\n\ttransform() {\n\t\ttransformVertices(\n\t\t\tthis.model.vertices,\n\t\t\tthis.vertices,\n\t\t\tthis.x,\n\t\t\tthis.y,\n\t\t\tthis.z,\n\t\t\tthis.rotateX,\n\t\t\tthis.rotateY,\n\t\t\tthis.rotateZ,\n\t\t\tthis.scaleX,\n\t\t\tthis.scaleY,\n\t\t\tthis.scaleZ\n\t\t);\n\n\t\tcopyVerticesTo(this.vertices, this.shadowVertices);\n\t}\n\n\t// Projects origin point, stored as `projected` property.\n\tproject() {\n\t\tprojectVertexTo(this, this.projected);\n\t}\n}\n\n\n\n\n\n// getTarget.js\n// ============================================================================\n// ============================================================================\n\n// All active targets\nconst targets = [];\n\n// Pool target instances by color, using a Map.\n// keys are color objects, and values are arrays of targets.\n// Also pool wireframe instances separately.\nconst targetPool = new Map(allColors.map(c=>([c, []])));\nconst targetWireframePool = new Map(allColors.map(c=>([c, []])));\n\n\n\nconst getTarget = (() => {\n\n\tconst slowmoSpawner = makeSpawner({\n\t\tchance: 0.5,\n\t\tcooldownPerSpawn: 10000,\n\t\tmaxSpawns: 1\n\t});\n\n\tlet doubleStrong = false;\n\tconst strongSpawner = makeSpawner({\n\t\tchance: 0.3,\n\t\tcooldownPerSpawn: 12000,\n\t\tmaxSpawns: 1\n\t});\n\n\tconst spinnerSpawner = makeSpawner({\n\t\tchance: 0.1,\n\t\tcooldownPerSpawn: 10000,\n\t\tmaxSpawns: 1\n\t});\n\n\t// Cached array instances, no need to allocate every time.\n\tconst axisOptions = [\n\t\t['x', 'y'],\n\t\t['y', 'z'],\n\t\t['z', 'x']\n\t];\n\n\tfunction getTargetOfStyle(color, wireframe) {\n\t\tconst pool = wireframe ? targetWireframePool : targetPool;\n\t\tlet target = pool.get(color).pop();\n\t\tif (!target) {\n\t\t\ttarget = new Entity({\n\t\t\t\tmodel: optimizeModel(makeRecursiveCubeModel({\n\t\t\t\t\trecursionLevel: 1,\n\t\t\t\t\tsplitFn: mengerSpongeSplit,\n\t\t\t\t\tscale: targetRadius\n\t\t\t\t})),\n\t\t\t\tcolor: color,\n\t\t\t\twireframe: wireframe\n\t\t\t});\n\n\t\t\t// Init any properties that will be used.\n\t\t\t// These will not be automatically reset when recycled.\n\t\t\ttarget.color = color;\n\t\t\ttarget.wireframe = wireframe;\n\t\t\t// Some properties don't have their final value yet.\n\t\t\t// Initialize with any value of the right type.\n\t\t\ttarget.hit = false;\n\t\t\ttarget.maxHealth = 0;\n\t\t\ttarget.health = 0;\n\t\t}\n\t\treturn target;\n\t}\n\n\treturn function getTarget() {\n\t\tif (doubleStrong && state.game.score <= doubleStrongEnableScore) {\n\t\t\tdoubleStrong = false;\n\t\t\t// Spawner is reset automatically when game resets.\n\t\t} else if (!doubleStrong && state.game.score > doubleStrongEnableScore) {\n\t\t\tdoubleStrong = true;\n\t\t\tstrongSpawner.mutate({ maxSpawns: 2 });\n\t\t}\n\n\t\t// Target Parameters\n\t\t// --------------------------------\n\t\tlet color = pickOne([BLUE, GREEN, ORANGE]);\n\t\tlet wireframe = false;\n\t\tlet health = 1;\n\t\tlet maxHealth = 3;\n\t\tconst spinner = state.game.cubeCount >= spinnerThreshold && isInGame() && spinnerSpawner.shouldSpawn();\n\n\t\t// Target Parameter Overrides\n\t\t// --------------------------------\n\t\tif (state.game.cubeCount >= slowmoThreshold && slowmoSpawner.shouldSpawn()) {\n\t\t\tcolor = BLUE;\n\t\t\twireframe = true;\n\t\t}\n\t\telse if (state.game.cubeCount >= strongThreshold && strongSpawner.shouldSpawn()) {\n\t\t\tcolor = PINK;\n\t\t\thealth = 3;\n\t\t}\n\n\t\t// Target Creation\n\t\t// --------------------------------\n\t\tconst target = getTargetOfStyle(color, wireframe);\n\t\ttarget.hit = false;\n\t\ttarget.maxHealth = maxHealth;\n\t\ttarget.health = health;\n\t\tupdateTargetHealth(target, 0);\n\n\t\tconst spinSpeeds = [\n\t\t\tMath.random() * 0.1 - 0.05,\n\t\t\tMath.random() * 0.1 - 0.05\n\t\t];\n\n\t\tif (spinner) {\n\t\t\t// Ends up spinning a random axis\n\t\t\tspinSpeeds[0] = -0.25;\n\t\t\tspinSpeeds[1] = 0;\n\t\t\ttarget.rotateZ = random(0, TAU);\n\t\t}\n\n\t\tconst axes = pickOne(axisOptions);\n\n\t\tspinSpeeds.forEach((spinSpeed, i) => {\n\t\t\tswitch (axes[i]) {\n\t\t\t\tcase 'x':\n\t\t\t\t\ttarget.rotateXD = spinSpeed;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'y':\n\t\t\t\t\ttarget.rotateYD = spinSpeed;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z':\n\t\t\t\t\ttarget.rotateZD = spinSpeed;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\treturn target;\n\t}\n})();\n\n\nconst updateTargetHealth = (target, healthDelta) => {\n\ttarget.health += healthDelta;\n\t// Only update stroke on non-wireframe targets.\n\t// Showing \"glue\" is a temporary attempt to display health. For now, there's\n\t// no reason to have wireframe targets with high health, so we're fine.\n\tif (!target.wireframe) {\n\t\tconst strokeWidth = target.health - 1;\n\t\tconst strokeColor = makeTargetGlueColor(target);\n\t\tfor (let p of target.polys) {\n\t\t\tp.strokeWidth = strokeWidth;\n\t\t\tp.strokeColor = strokeColor;\n\t\t}\n\t}\n};\n\n\nconst returnTarget = target => {\n\ttarget.reset();\n\tconst pool = target.wireframe ? targetWireframePool : targetPool;\n\tpool.get(target.color).push(target);\n};\n\n\nfunction resetAllTargets() {\n\twhile(targets.length) {\n\t\treturnTarget(targets.pop());\n\t}\n}\n\n\n\n\n\n// createBurst.js\n// ============================================================================\n// ============================================================================\n\n// Track all active fragments\nconst frags = [];\n// Pool inactive fragments by color, using a Map.\n// keys are color objects, and values are arrays of fragments.\n// // Also pool wireframe instances separately.\nconst fragPool = new Map(allColors.map(c=>([c, []])));\nconst fragWireframePool = new Map(allColors.map(c=>([c, []])));\n\n\nconst createBurst = (() => {\n\t// Precompute some private data to be reused for all bursts.\n\tconst basePositions = mengerSpongeSplit({ x:0, y:0, z:0 }, fragRadius*2);\n\tconst positions = cloneVertices(basePositions);\n\tconst prevPositions = cloneVertices(basePositions);\n\tconst velocities = cloneVertices(basePositions);\n\n\tconst basePositionNormals = basePositions.map(normalize);\n\tconst positionNormals = cloneVertices(basePositionNormals);\n\n\n\tconst fragCount = basePositions.length;\n\n\tfunction getFragForTarget(target) {\n\t\tconst pool = target.wireframe ? fragWireframePool : fragPool;\n\t\tlet frag = pool.get(target.color).pop();\n\t\tif (!frag) {\n\t\t\tfrag = new Entity({\n\t\t\t\tmodel: makeCubeModel({ scale: fragRadius }),\n\t\t\t\tcolor: target.color,\n\t\t\t\twireframe: target.wireframe\n\t\t\t});\n\t\t\tfrag.color = target.color;\n\t\t\tfrag.wireframe = target.wireframe;\n\t\t}\n\t\treturn frag;\n\t}\n\n\treturn (target, force=1) => {\n\t\t// Calculate fragment positions, and what would have been the previous positions\n\t\t// when still a part of the larger target.\n\t\ttransformVertices(\n\t\t\tbasePositions, positions,\n\t\t\ttarget.x, target.y, target.z,\n\t\t\ttarget.rotateX, target.rotateY, target.rotateZ,\n\t\t\t1, 1, 1\n\t\t);\n\t\ttransformVertices(\n\t\t\tbasePositions, prevPositions,\n\t\t\ttarget.x - target.xD, target.y - target.yD, target.z - target.zD,\n\t\t\ttarget.rotateX - target.rotateXD, target.rotateY - target.rotateYD, target.rotateZ - target.rotateZD,\n\t\t\t1, 1, 1\n\t\t);\n\n\t\t// Compute velocity of each fragment, based on previous positions.\n\t\t// Will write to `velocities` array.\n\t\tfor (let i=0; i<fragCount; i++) {\n\t\t\tconst position = positions[i];\n\t\t\tconst prevPosition = prevPositions[i];\n\t\t\tconst velocity = velocities[i];\n\n\t\t\tvelocity.x = position.x - prevPosition.x;\n\t\t\tvelocity.y = position.y - prevPosition.y;\n\t\t\tvelocity.z = position.z - prevPosition.z;\n\t\t}\n\n\n\n\t\t// Apply target rotation to normals\n\t\ttransformVertices(\n\t\t\tbasePositionNormals, positionNormals,\n\t\t\t0, 0, 0,\n\t\t\ttarget.rotateX, target.rotateY, target.rotateZ,\n\t\t\t1, 1, 1\n\t\t);\n\n\n\t\tfor (let i=0; i<fragCount; i++) {\n\t\t\tconst position = positions[i];\n\t\t\tconst velocity = velocities[i];\n\t\t\tconst normal = positionNormals[i];\n\n\t\t\tconst frag = getFragForTarget(target);\n\n\t\t\tfrag.x = position.x;\n\t\t\tfrag.y = position.y;\n\t\t\tfrag.z = position.z;\n\t\t\tfrag.rotateX = target.rotateX;\n\t\t\tfrag.rotateY = target.rotateY;\n\t\t\tfrag.rotateZ = target.rotateZ;\n\n\n\t\t\tconst burstSpeed = 2 * force;\n\t\t\tconst randSpeed = 2 * force;\n\t\t\tconst rotateScale = 0.015;\n\t\t\tfrag.xD = velocity.x + (normal.x * burstSpeed) + (Math.random() * randSpeed);\n\t\t\tfrag.yD = velocity.y + (normal.y * burstSpeed) + (Math.random() * randSpeed);\n\t\t\tfrag.zD = velocity.z + (normal.z * burstSpeed) + (Math.random() * randSpeed);\n\t\t\tfrag.rotateXD = frag.xD * rotateScale;\n\t\t\tfrag.rotateYD = frag.yD * rotateScale;\n\t\t\tfrag.rotateZD = frag.zD * rotateScale;\n\n\t\t\tfrags.push(frag);\n\t\t};\n\t}\n})();\n\n\nconst returnFrag = frag => {\n\tfrag.reset();\n\tconst pool = frag.wireframe ? fragWireframePool : fragPool;\n\tpool.get(frag.color).push(frag);\n};\n\n\n\n\n\n// sparks.js\n// ============================================================================\n// ============================================================================\n\nconst sparks = [];\nconst sparkPool = [];\n\n\nfunction addSpark(x, y, xD, yD) {\n\tconst spark = sparkPool.pop() || {};\n\n\tspark.x = x + xD * 0.5;\n\tspark.y = y + yD * 0.5;\n\tspark.xD = xD;\n\tspark.yD = yD;\n\tspark.life = random(200, 300);\n\tspark.maxLife = spark.life;\n\n\tsparks.push(spark);\n\n\treturn spark;\n}\n\n\n// Spherical spark burst\nfunction sparkBurst(x, y, count, maxSpeed) {\n\tconst angleInc = TAU / count;\n\tfor (let i=0; i<count; i++) {\n\t\tconst angle = i * angleInc + angleInc * Math.random();\n\t\tconst speed = (1 - Math.random() ** 3) * maxSpeed;\n\t\taddSpark(\n\t\t\tx,\n\t\t\ty,\n\t\t\tMath.sin(angle) * speed,\n\t\t\tMath.cos(angle) * speed\n\t\t);\n\t}\n}\n\n\n// Make a target \"leak\" sparks from all vertices.\n// This is used to create the effect of target glue \"shedding\".\nlet glueShedVertices;\nfunction glueShedSparks(target) {\n\tif (!glueShedVertices) {\n\t\tglueShedVertices = cloneVertices(target.vertices);\n\t} else {\n\t\tcopyVerticesTo(target.vertices, glueShedVertices);\n\t}\n\n\tglueShedVertices.forEach(v => {\n\t\tif (Math.random() < 0.4) {\n\t\t\tprojectVertex(v);\n\t\t\taddSpark(\n\t\t\t\tv.x,\n\t\t\t\tv.y,\n\t\t\t\trandom(-12, 12),\n\t\t\t\trandom(-12, 12)\n\t\t\t);\n\t\t}\n\t});\n}\n\nfunction returnSpark(spark) {\n\tsparkPool.push(spark);\n}\n\n\n\n\n\n// hud.js\n// ============================================================================\n// ============================================================================\n\nconst hudContainerNode = $('.hud');\n\nfunction setHudVisibility(visible) {\n\tif (visible) {\n\t\thudContainerNode.style.display = 'block';\n\t} else {\n\t\thudContainerNode.style.display = 'none';\n\t}\n}\n\n\n///////////\n// Score //\n///////////\nconst scoreNode = $('.score-lbl');\nconst cubeCountNode = $('.cube-count-lbl');\n\nfunction renderScoreHud() {\n\tif (isCasualGame()) {\n\t\tscoreNode.style.display = 'none';\n\t\tcubeCountNode.style.opacity = 1;\n\t} else {\n\t\tscoreNode.innerText = `SCORE: ${state.game.score}`;\n\t\tscoreNode.style.display = 'block';\n\t\tcubeCountNode.style.opacity = 0.65 ;\n\t}\n\tcubeCountNode.innerText = `CUBES SMASHED: ${state.game.cubeCount}`;\n}\n\nrenderScoreHud();\n\n\n//////////////////\n// Pause Button //\n//////////////////\n\nhandlePointerDown($('.pause-btn'), () => pauseGame());\n\n\n////////////////////\n// Slow-Mo Status //\n////////////////////\n\nconst slowmoNode = $('.slowmo');\nconst slowmoBarNode = $('.slowmo__bar');\n\nfunction renderSlowmoStatus(percentRemaining) {\n\tslowmoNode.style.opacity = percentRemaining === 0 ? 0 : 1;\n\tslowmoBarNode.style.transform = `scaleX(${percentRemaining.toFixed(3)})`;\n}\n\n\n\n\n\n// menus.js\n// ============================================================================\n// ============================================================================\n\n// Top-level menu containers\nconst menuContainerNode = $('.menus');\nconst menuMainNode = $('.menu--main');\nconst menuPauseNode = $('.menu--pause');\nconst menuScoreNode = $('.menu--score');\n\nconst finalScoreLblNode = $('.final-score-lbl');\nconst highScoreLblNode = $('.high-score-lbl');\n\n\n\nfunction showMenu(node) {\n\tnode.classList.add('active');\n}\n\nfunction hideMenu(node) {\n\tnode.classList.remove('active');\n}\n\nfunction renderMenus() {\n\thideMenu(menuMainNode);\n\thideMenu(menuPauseNode);\n\thideMenu(menuScoreNode);\n\n\tswitch (state.menus.active) {\n\t\tcase MENU_MAIN:\n\t\t\tshowMenu(menuMainNode);\n\t\t\tbreak;\n\t\tcase MENU_PAUSE:\n\t\t\tshowMenu(menuPauseNode);\n\t\t\tbreak;\n\t\tcase MENU_SCORE:\n\t\t\tfinalScoreLblNode.textContent = formatNumber(state.game.score);\n\t\t\tif (isNewHighScore()) {\n\t\t\t\thighScoreLblNode.textContent = 'New High Score!';\n\t\t\t} else {\n\t\t\t\thighScoreLblNode.textContent = `High Score: ${formatNumber(getHighScore())}`;\n\t\t\t}\n\t\t\tshowMenu(menuScoreNode);\n\t\t\tbreak;\n\t}\n\n\tsetHudVisibility(!isMenuVisible());\n\tmenuContainerNode.classList.toggle('has-active', isMenuVisible());\n\tmenuContainerNode.classList.toggle('interactive-mode', isMenuVisible() && pointerIsDown);\n}\n\nrenderMenus();\n\n\n\n////////////////////\n// Button Actions //\n////////////////////\n\n// Main Menu\nhandleClick($('.play-normal-btn'), () => {\n\tsetGameMode(GAME_MODE_RANKED);\n\tsetActiveMenu(null);\n\tresetGame();\n});\n\nhandleClick($('.play-casual-btn'), () => {\n\tsetGameMode(GAME_MODE_CASUAL);\n\tsetActiveMenu(null);\n\tresetGame();\n});\n\n// Pause Menu\nhandleClick($('.resume-btn'), () => resumeGame());\nhandleClick($('.menu-btn--pause'), () => setActiveMenu(MENU_MAIN));\n\n// Score Menu\nhandleClick($('.play-again-btn'), () => {\n\tsetActiveMenu(null);\n\tresetGame();\n});\n\nhandleClick($('.menu-btn--score'), () => setActiveMenu(MENU_MAIN));\n\n\n\n\n////////////////////\n// Button Actions //\n////////////////////\n\n// Main Menu\nhandleClick($('.play-normal-btn'), () => {\n\tsetGameMode(GAME_MODE_RANKED);\n\tsetActiveMenu(null);\n\tresetGame();\n});\n\nhandleClick($('.play-casual-btn'), () => {\n\tsetGameMode(GAME_MODE_CASUAL);\n\tsetActiveMenu(null);\n\tresetGame();\n});\n\n// Pause Menu\nhandleClick($('.resume-btn'), () => resumeGame());\nhandleClick($('.menu-btn--pause'), () => setActiveMenu(MENU_MAIN));\n\n// Score Menu\nhandleClick($('.play-again-btn'), () => {\n\tsetActiveMenu(null);\n\tresetGame();\n});\n\nhandleClick($('.menu-btn--score'), () => setActiveMenu(MENU_MAIN));\n\n\n\n\n\n// actions.js\n// ============================================================================\n// ============================================================================\n\n//////////////////\n// MENU ACTIONS //\n//////////////////\n\nfunction setActiveMenu(menu) {\n\tstate.menus.active = menu;\n\trenderMenus();\n}\n\n\n/////////////////\n// HUD ACTIONS //\n/////////////////\n\nfunction setScore(score) {\n\tstate.game.score = score;\n\trenderScoreHud();\n}\n\nfunction incrementScore(inc) {\n\tif (isInGame()) {\n\t\tstate.game.score += inc;\n\t\tif (state.game.score < 0) {\n\t\t\tstate.game.score = 0;\n\t\t}\n\t\trenderScoreHud();\n\t}\n}\n\nfunction setCubeCount(count) {\n\tstate.game.cubeCount = count;\n\trenderScoreHud();\n}\n\nfunction incrementCubeCount(inc) {\n\tif (isInGame()) {\n\t\tstate.game.cubeCount += inc;\n\t\trenderScoreHud();\n\t}\n}\n\n\n//////////////////\n// GAME ACTIONS //\n//////////////////\n\nfunction setGameMode(mode) {\n\tstate.game.mode = mode;\n}\n\nfunction resetGame() {\n\tresetAllTargets();\n\tstate.game.time = 0;\n\tresetAllCooldowns();\n\tsetScore(0);\n\tsetCubeCount(0);\n\tspawnTime = getSpawnDelay();\n}\n\nfunction pauseGame() {\n\tisInGame() && setActiveMenu(MENU_PAUSE);\n}\n\nfunction resumeGame() {\n\tisPaused() && setActiveMenu(null);\n}\n\nfunction endGame() {\n\thandleCanvasPointerUp();\n\tif (isNewHighScore()) {\n\t\tsetHighScore(state.game.score);\n\t}\n\tsetActiveMenu(MENU_SCORE);\n}\n\n\n\n////////////////////////\n// KEYBOARD SHORTCUTS //\n////////////////////////\n\nwindow.addEventListener('keydown', event => {\n\tif (event.key === 'p') {\n\t\tisPaused() ? resumeGame() : pauseGame();\n\t}\n});\n\n\n\n\n\n\n// tick.js\n// ============================================================================\n// ============================================================================\n\n\nlet spawnTime = 0;\nconst maxSpawnX = 450;\nconst pointerDelta = { x: 0, y: 0 };\nconst pointerDeltaScaled = { x: 0, y: 0 };\n\n// Temp slowmo state. Should be relocated once this stabilizes.\nconst slowmoDuration = 1500;\nlet slowmoRemaining = 0;\nlet spawnExtra = 0;\nconst spawnExtraDelay = 300;\nlet targetSpeed = 1;\n\n\nfunction tick(width, height, simTime, simSpeed, lag) {\n\tPERF_START('frame');\n\tPERF_START('tick');\n\n\tstate.game.time += simTime;\n\n\tif (slowmoRemaining > 0) {\n\t\tslowmoRemaining -= simTime;\n\t\tif (slowmoRemaining < 0) {\n\t\t\tslowmoRemaining = 0;\n\t\t}\n\t\ttargetSpeed = pointerIsDown ? 0.075 : 0.3;\n\t} else {\n\t\tconst menuPointerDown = isMenuVisible() && pointerIsDown;\n\t\ttargetSpeed = menuPointerDown ? 0.025 : 1;\n\t}\n\n\trenderSlowmoStatus(slowmoRemaining / slowmoDuration);\n\n\tgameSpeed += (targetSpeed - gameSpeed) / 22 * lag;\n\tgameSpeed = clamp(gameSpeed, 0, 1);\n\n\tconst centerX = width / 2;\n\tconst centerY = height / 2;\n\n\tconst simAirDrag = 1 - (airDrag * simSpeed);\n\tconst simAirDragSpark = 1 - (airDragSpark * simSpeed);\n\n\t// Pointer Tracking\n\t// -------------------\n\n\t// Compute speed and x/y deltas.\n\t// There is also a \"scaled\" variant taking game speed into account. This serves two purposes:\n\t//  - Lag won't create large spikes in speed/deltas\n\t//  - In slow mo, speed is increased proportionately to match \"reality\". Without this boost,\n\t//    it feels like your actions are dampened in slow mo.\n\tconst forceMultiplier = 1 / (simSpeed * 0.75 + 0.25);\n\tpointerDelta.x = 0;\n\tpointerDelta.y = 0;\n\tpointerDeltaScaled.x = 0;\n\tpointerDeltaScaled.y = 0;\n\tconst lastPointer = touchPoints[touchPoints.length - 1];\n\n\tif (pointerIsDown && lastPointer && !lastPointer.touchBreak) {\n\t\tpointerDelta.x = (pointerScene.x - lastPointer.x);\n\t\tpointerDelta.y = (pointerScene.y - lastPointer.y);\n\t\tpointerDeltaScaled.x = pointerDelta.x * forceMultiplier;\n\t\tpointerDeltaScaled.y = pointerDelta.y * forceMultiplier;\n\t}\n\tconst pointerSpeed = Math.hypot(pointerDelta.x, pointerDelta.y);\n\tconst pointerSpeedScaled = pointerSpeed * forceMultiplier;\n\n\t// Track points for later calculations, including drawing trail.\n\ttouchPoints.forEach(p => p.life -= simTime);\n\n\tif (pointerIsDown) {\n\t\ttouchPoints.push({\n\t\t\tx: pointerScene.x,\n\t\t\ty: pointerScene.y,\n\t\t\tlife: touchPointLife\n\t\t});\n\t}\n\n\twhile (touchPoints[0] && touchPoints[0].life <= 0) {\n\t\ttouchPoints.shift();\n\t}\n\n\n\t// Entity Manipulation\n\t// --------------------\n\tPERF_START('entities');\n\n\t// Spawn targets\n\tspawnTime -= simTime;\n\tif (spawnTime <= 0) {\n\t\tif (spawnExtra > 0) {\n\t\t\tspawnExtra--;\n\t\t\tspawnTime = spawnExtraDelay;\n\t\t} else {\n\t\t\tspawnTime = getSpawnDelay();\n\t\t}\n\t\tconst target = getTarget();\n\t\tconst spawnRadius = Math.min(centerX * 0.8, maxSpawnX);\n\t\ttarget.x = (Math.random() * spawnRadius * 2 - spawnRadius);\n\t\ttarget.y = centerY + targetHitRadius * 2;\n\t\ttarget.z = (Math.random() * targetRadius*2 - targetRadius);\n\t\ttarget.xD = Math.random() * (target.x * -2 / 120);\n\t\ttarget.yD = -20;\n\t\ttargets.push(target);\n\t}\n\n\t// Animate targets and remove when offscreen\n\tconst leftBound = -centerX + targetRadius;\n\tconst rightBound = centerX - targetRadius;\n\tconst ceiling = -centerY - 120;\n\tconst boundDamping = 0.4;\n\n\ttargetLoop:\n\tfor (let i = targets.length - 1; i >= 0; i--) {\n\t\tconst target = targets[i];\n\t\ttarget.x += target.xD * simSpeed;\n\t\ttarget.y += target.yD * simSpeed;\n\n\t\tif (target.y < ceiling) {\n\t\t\ttarget.y = ceiling;\n\t\t\ttarget.yD = 0;\n\t\t}\n\n\t\tif (target.x < leftBound) {\n\t\t\ttarget.x = leftBound;\n\t\t\ttarget.xD *= -boundDamping;\n\t\t} else if (target.x > rightBound) {\n\t\t\ttarget.x = rightBound;\n\t\t\ttarget.xD *= -boundDamping;\n\t\t}\n\n\t\tif (target.z < backboardZ) {\n\t\t\ttarget.z = backboardZ;\n\t\t\ttarget.zD *= -boundDamping;\n\t\t}\n\n\t\ttarget.yD += gravity * simSpeed;\n\t\ttarget.rotateX += target.rotateXD * simSpeed;\n\t\ttarget.rotateY += target.rotateYD * simSpeed;\n\t\ttarget.rotateZ += target.rotateZD * simSpeed;\n\t\ttarget.transform();\n\t\ttarget.project();\n\n\t\t// Remove if offscreen\n\t\tif (target.y > centerY + targetHitRadius * 2) {\n\t\t\ttargets.splice(i, 1);\n\t\t\treturnTarget(target);\n\t\t\tif (isInGame()) {\n\t\t\t\tif (isCasualGame()) {\n\t\t\t\t\tincrementScore(-25);\n\t\t\t\t} else {\n\t\t\t\t\tendGame();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t// If pointer is moving really fast, we want to hittest multiple points along the path.\n\t\t// We can't use scaled pointer speed to determine this, since we care about actual screen\n\t\t// distance covered.\n\t\tconst hitTestCount = Math.ceil(pointerSpeed / targetRadius * 2);\n\t\t// Start loop at `1` and use `<=` check, so we skip 0% and end up at 100%.\n\t\t// This omits the previous point position, and includes the most recent.\n\t\tfor (let ii=1; ii<=hitTestCount; ii++) {\n\t\t\tconst percent = 1 - (ii / hitTestCount);\n\t\t\tconst hitX = pointerScene.x - pointerDelta.x * percent;\n\t\t\tconst hitY = pointerScene.y - pointerDelta.y * percent;\n\t\t\tconst distance = Math.hypot(\n\t\t\t\thitX - target.projected.x,\n\t\t\t\thitY - target.projected.y\n\t\t\t);\n\n\t\t\tif (distance <= targetHitRadius) {\n\t\t\t\t// Hit! (though we don't want to allow hits on multiple sequential frames)\n\t\t\t\tif (!target.hit) {\n\t\t\t\t\ttarget.hit = true;\n\n\t\t\t\t\ttarget.xD += pointerDeltaScaled.x * hitDampening;\n\t\t\t\t\ttarget.yD += pointerDeltaScaled.y * hitDampening;\n\t\t\t\t\ttarget.rotateXD += pointerDeltaScaled.y * 0.001;\n\t\t\t\t\ttarget.rotateYD += pointerDeltaScaled.x * 0.001;\n\n\t\t\t\t\tconst sparkSpeed = 7 + pointerSpeedScaled * 0.125;\n\n\t\t\t\t\tif (pointerSpeedScaled > minPointerSpeed) {\n\t\t\t\t\t\ttarget.health--;\n\t\t\t\t\t\tincrementScore(10);\n\n\t\t\t\t\t\tif (target.health <= 0) {\n\t\t\t\t\t\t\tincrementCubeCount(1);\n\t\t\t\t\t\t\tcreateBurst(target, forceMultiplier);\n\t\t\t\t\t\t\tsparkBurst(hitX, hitY, 8, sparkSpeed);\n\t\t\t\t\t\t\tif (target.wireframe) {\n\t\t\t\t\t\t\t\tslowmoRemaining = slowmoDuration;\n\t\t\t\t\t\t\t\tspawnTime = 0;\n\t\t\t\t\t\t\t\tspawnExtra = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttargets.splice(i, 1);\n\t\t\t\t\t\t\treturnTarget(target);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsparkBurst(hitX, hitY, 8, sparkSpeed);\n\t\t\t\t\t\t\tglueShedSparks(target);\n\t\t\t\t\t\t\tupdateTargetHealth(target, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tincrementScore(5);\n\t\t\t\t\t\tsparkBurst(hitX, hitY, 3, sparkSpeed);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Break the current loop and continue the outer loop.\n\t\t\t\t// This skips to processing the next target.\n\t\t\t\tcontinue targetLoop;\n\t\t\t}\n\t\t}\n\n\t\t// This code will only run if target hasn't been \"hit\".\n\t\ttarget.hit = false;\n\t}\n\n\t// Animate fragments and remove when offscreen.\n\tconst fragBackboardZ = backboardZ + fragRadius;\n\t// Allow fragments to move off-screen to sides for a while, since shadows are still visible.\n\tconst fragLeftBound = -width;\n\tconst fragRightBound = width;\n\n\tfor (let i = frags.length - 1; i >= 0; i--) {\n\t\tconst frag = frags[i];\n\t\tfrag.x += frag.xD * simSpeed;\n\t\tfrag.y += frag.yD * simSpeed;\n\t\tfrag.z += frag.zD * simSpeed;\n\n\t\tfrag.xD *= simAirDrag;\n\t\tfrag.yD *= simAirDrag;\n\t\tfrag.zD *= simAirDrag;\n\n\t\tif (frag.y < ceiling) {\n\t\t\tfrag.y = ceiling;\n\t\t\tfrag.yD = 0;\n\t\t}\n\n\t\tif (frag.z < fragBackboardZ) {\n\t\t\tfrag.z = fragBackboardZ;\n\t\t\tfrag.zD *= -boundDamping;\n\t\t}\n\n\t\tfrag.yD += gravity * simSpeed;\n\t\tfrag.rotateX += frag.rotateXD * simSpeed;\n\t\tfrag.rotateY += frag.rotateYD * simSpeed;\n\t\tfrag.rotateZ += frag.rotateZD * simSpeed;\n\t\tfrag.transform();\n\t\tfrag.project();\n\n\t\t// Removal conditions\n\t\tif (\n\t\t\t// Bottom of screen\n\t\t\tfrag.projected.y > centerY + targetHitRadius ||\n\t\t\t// Sides of screen\n\t\t\tfrag.projected.x < fragLeftBound ||\n\t\t\tfrag.projected.x > fragRightBound ||\n\t\t\t// Too close to camera\n\t\t\tfrag.z > cameraFadeEndZ\n\t\t) {\n\t\t\tfrags.splice(i, 1);\n\t\t\treturnFrag(frag);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t// 2D sparks\n\tfor (let i = sparks.length - 1; i >= 0; i--) {\n\t\tconst spark = sparks[i];\n\t\tspark.life -= simTime;\n\t\tif (spark.life <= 0) {\n\t\t\tsparks.splice(i, 1);\n\t\t\treturnSpark(spark);\n\t\t\tcontinue;\n\t\t}\n\t\tspark.x += spark.xD * simSpeed;\n\t\tspark.y += spark.yD * simSpeed;\n\t\tspark.xD *= simAirDragSpark;\n\t\tspark.yD *= simAirDragSpark;\n\t\tspark.yD += gravity * simSpeed;\n\t}\n\n\tPERF_END('entities');\n\n\t// 3D transforms\n\t// -------------------\n\n\tPERF_START('3D');\n\n\t// Aggregate all scene vertices/polys\n\tallVertices.length = 0;\n\tallPolys.length = 0;\n\tallShadowVertices.length = 0;\n\tallShadowPolys.length = 0;\n\ttargets.forEach(entity => {\n\t\tallVertices.push(...entity.vertices);\n\t\tallPolys.push(...entity.polys);\n\t\tallShadowVertices.push(...entity.shadowVertices);\n\t\tallShadowPolys.push(...entity.shadowPolys);\n\t});\n\n\tfrags.forEach(entity => {\n\t\tallVertices.push(...entity.vertices);\n\t\tallPolys.push(...entity.polys);\n\t\tallShadowVertices.push(...entity.shadowVertices);\n\t\tallShadowPolys.push(...entity.shadowPolys);\n\t});\n\n\t// Scene calculations/transformations\n\tallPolys.forEach(p => computePolyNormal(p, 'normalWorld'));\n\tallPolys.forEach(computePolyDepth);\n\tallPolys.sort((a, b) => b.depth - a.depth);\n\n\t// Perspective projection\n\tallVertices.forEach(projectVertex);\n\n\tallPolys.forEach(p => computePolyNormal(p, 'normalCamera'));\n\n\tPERF_END('3D');\n\n\tPERF_START('shadows');\n\n\t// Rotate shadow vertices to light source perspective\n\ttransformVertices(\n\t\tallShadowVertices,\n\t\tallShadowVertices,\n\t\t0, 0, 0,\n\t\tTAU/8, 0, 0,\n\t\t1, 1, 1\n\t);\n\n\tallShadowPolys.forEach(p => computePolyNormal(p, 'normalWorld'));\n\n\tconst shadowDistanceMult = Math.hypot(1, 1);\n\tconst shadowVerticesLength = allShadowVertices.length;\n\tfor (let i=0; i<shadowVerticesLength; i++) {\n\t\tconst distance = allVertices[i].z - backboardZ;\n\t\tallShadowVertices[i].z -= shadowDistanceMult * distance;\n\t}\n\ttransformVertices(\n\t\tallShadowVertices,\n\t\tallShadowVertices,\n\t\t0, 0, 0,\n\t\t-TAU/8, 0, 0,\n\t\t1, 1, 1\n\t);\n\tallShadowVertices.forEach(projectVertex);\n\n\tPERF_END('shadows');\n\n\tPERF_END('tick');\n}\n\n\n\n\n\n// draw.js\n// ============================================================================\n// ============================================================================\n\nfunction draw(ctx, width, height, viewScale) {\n\tPERF_START('draw');\n\n\tconst halfW = width / 2;\n\tconst halfH = height / 2;\n\n\n\t// 3D Polys\n\t// ---------------\n\tctx.lineJoin = 'bevel';\n\n\tPERF_START('drawShadows');\n\tctx.fillStyle = shadowColor;\n\tctx.strokeStyle = shadowColor;\n\tallShadowPolys.forEach(p => {\n\t\tif (p.wireframe) {\n\t\t\tctx.lineWidth = 2;\n\t\t\tctx.beginPath();\n\t\t\tconst { vertices } = p;\n\t\t\tconst vCount = vertices.length;\n\t\t\tconst firstV = vertices[0];\n\t\t\tctx.moveTo(firstV.x, firstV.y);\n\t\t\tfor (let i=1; i<vCount; i++) {\n\t\t\t\tconst v = vertices[i];\n\t\t\t\tctx.lineTo(v.x, v.y);\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\t\t} else {\n\t\t\tctx.beginPath();\n\t\t\tconst { vertices } = p;\n\t\t\tconst vCount = vertices.length;\n\t\t\tconst firstV = vertices[0];\n\t\t\tctx.moveTo(firstV.x, firstV.y);\n\t\t\tfor (let i=1; i<vCount; i++) {\n\t\t\t\tconst v = vertices[i];\n\t\t\t\tctx.lineTo(v.x, v.y);\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t\tctx.fill();\n\t\t}\n\t});\n\tPERF_END('drawShadows');\n\n\tPERF_START('drawPolys');\n\n\tallPolys.forEach(p => {\n\t\tif (!p.wireframe && p.normalCamera.z < 0) return;\n\n\t\tif (p.strokeWidth !== 0) {\n\t\t\tctx.lineWidth = p.normalCamera.z < 0 ? p.strokeWidth * 0.5 : p.strokeWidth;\n\t\t\tctx.strokeStyle = p.normalCamera.z < 0 ? p.strokeColorDark : p.strokeColor;\n\t\t}\n\n\t\tconst { vertices } = p;\n\t\tconst lastV = vertices[vertices.length - 1];\n\t\tconst fadeOut = p.middle.z > cameraFadeStartZ;\n\n\t\tif (!p.wireframe) {\n\t\t\tconst normalLight = p.normalWorld.y * 0.5 + p.normalWorld.z * -0.5;\n\t\t\tconst lightness = normalLight > 0\n\t\t\t\t? 0.1\n\t\t\t\t: ((normalLight ** 32 - normalLight) / 2) * 0.9 + 0.1;\n\t\t\tctx.fillStyle = shadeColor(p.color, lightness);\n\t\t}\n\n\t\t// Fade out polys close to camera. `globalAlpha` must be reset later.\n\t\tif (fadeOut) {\n\t\t\t// If polygon gets really close to camera (outside `cameraFadeRange`) the alpha\n\t\t\t// can go negative, which has the appearance of alpha = 1. So, we'll clamp it at 0.\n\t\t\tctx.globalAlpha = Math.max(0, 1 - (p.middle.z - cameraFadeStartZ) / cameraFadeRange);\n\t\t}\n\n\t\tctx.beginPath();\n\t\tctx.moveTo(lastV.x, lastV.y);\n\t\tfor (let v of vertices) {\n\t\t\tctx.lineTo(v.x, v.y);\n\t\t}\n\n\t\tif (!p.wireframe) {\n\t\t\tctx.fill();\n\t\t}\n\t\tif (p.strokeWidth !== 0) {\n\t\t\tctx.stroke();\n\t\t}\n\n\t\tif (fadeOut) {\n\t\t\tctx.globalAlpha = 1;\n\t\t}\n\t});\n\tPERF_END('drawPolys');\n\n\n\tPERF_START('draw2D');\n\n\t// 2D Sparks\n\t// ---------------\n\tctx.strokeStyle = sparkColor;\n\tctx.lineWidth = sparkThickness;\n\tctx.beginPath();\n\tsparks.forEach(spark => {\n\t\tctx.moveTo(spark.x, spark.y);\n\t\t// Shrink sparks to zero length as they die.\n\t\t// Speed up shrinking as life approaches 0 (root curve).\n\t\t// Note that sparks already get smaller over time as their speed slows\n\t\t// down from damping. So this is like a double scale down. To counter this\n\t\t// a bit and keep the sparks larger for longer, we'll also increase the scale\n\t\t// a bit after applying the root curve.\n\t\tconst scale = (spark.life / spark.maxLife) ** 0.5 * 1.5;\n\t\tctx.lineTo(spark.x - spark.xD*scale, spark.y - spark.yD*scale);\n\n\t});\n\tctx.stroke();\n\n\n\t// Touch Strokes\n\t// ---------------\n\n\tctx.strokeStyle = touchTrailColor;\n\tconst touchPointCount = touchPoints.length;\n\tfor (let i=1; i<touchPointCount; i++) {\n\t\tconst current = touchPoints[i];\n\t\tconst prev = touchPoints[i-1];\n\t\tif (current.touchBreak || prev.touchBreak) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst scale = current.life / touchPointLife;\n\t\tctx.lineWidth = scale * touchTrailThickness;\n\t\tctx.beginPath();\n\t\tctx.moveTo(prev.x, prev.y);\n\t\tctx.lineTo(current.x, current.y);\n\t\tctx.stroke();\n\t}\n\n\tPERF_END('draw2D');\n\n\tPERF_END('draw');\n\tPERF_END('frame');\n\n\t// Display performance updates.\n\tPERF_UPDATE();\n}\n\n\n\n\n\n// canvas.js\n// ============================================================================\n// ============================================================================\n\nfunction setupCanvases() {\n\tconst ctx = canvas.getContext('2d');\n\t// devicePixelRatio alias\n\tconst dpr = window.devicePixelRatio || 1;\n\t// View will be scaled so objects appear sized similarly on all screen sizes.\n\tlet viewScale;\n\t// Dimensions (taking viewScale into account!)\n\tlet width, height;\n\n\tfunction handleResize() {\n\t\tconst w = window.innerWidth;\n\t\tconst h = window.innerHeight;\n\t\tviewScale = h / 1000;\n\t\twidth = w / viewScale;\n\t\theight = h / viewScale;\n\t\tcanvas.width = w * dpr;\n\t\tcanvas.height = h * dpr;\n\t\tcanvas.style.width = w + 'px';\n\t\tcanvas.style.height = h + 'px';\n\t}\n\n\t// Set initial size\n\thandleResize();\n\t// resize fullscreen canvas\n\twindow.addEventListener('resize', handleResize);\n\n\n\t// Run game loop\n\tlet lastTimestamp = 0;\n\tfunction frameHandler(timestamp) {\n\t\tlet frameTime = timestamp - lastTimestamp;\n\t\tlastTimestamp = timestamp;\n\n\t\t// always queue another frame\n\t\traf();\n\n\t\t// If game is paused, we'll still track frameTime (above) but all other\n\t\t// game logic and drawing can be avoided.\n\t\tif (isPaused()) return;\n\n\t\t// make sure negative time isn't reported (first frame can be whacky)\n\t\tif (frameTime < 0) {\n\t\t\tframeTime = 17;\n\t\t}\n\t\t// - cap minimum framerate to 15fps[~68ms] (assuming 60fps[~17ms] as 'normal')\n\t\telse if (frameTime > 68) {\n\t\t\tframeTime = 68;\n\t\t}\n\n\t\tconst halfW = width / 2;\n\t\tconst halfH = height / 2;\n\n\t\t// Convert pointer position from screen to scene coords.\n\t\tpointerScene.x = pointerScreen.x / viewScale - halfW;\n\t\tpointerScene.y = pointerScreen.y / viewScale - halfH;\n\n\t\tconst lag = frameTime / 16.6667;\n\t\tconst simTime = gameSpeed * frameTime;\n\t\tconst simSpeed = gameSpeed * lag;\n\t\ttick(width, height, simTime, simSpeed, lag);\n\n\t\t// Auto clear canvas\n\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\t// Auto scale drawing for high res displays, and incorporate `viewScale`.\n\t\t// Also shift canvas so (0, 0) is the middle of the screen.\n\t\t// This just works with 3D perspective projection.\n\t\tconst drawScale = dpr * viewScale;\n\t\tctx.scale(drawScale, drawScale);\n\t\tctx.translate(halfW, halfH);\n\t\tdraw(ctx, width, height, viewScale);\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t}\n\tconst raf = () => requestAnimationFrame(frameHandler);\n\t// Start loop\n\traf();\n}\n\n\n\n\n\n// interaction.js\n// ============================================================================\n// ============================================================================\n\n// Interaction\n// -----------------------------\n\nfunction handleCanvasPointerDown(x, y) {\n\tif (!pointerIsDown) {\n\t\tpointerIsDown = true;\n\t\tpointerScreen.x = x;\n\t\tpointerScreen.y = y;\n\t\t// On when menus are open, point down/up toggles an interactive mode.\n\t\t// We just need to rerender the menu system for it to respond.\n\t\tif (isMenuVisible()) renderMenus();\n\t}\n}\n\nfunction handleCanvasPointerUp() {\n\tif (pointerIsDown) {\n\t\tpointerIsDown = false;\n\t\ttouchPoints.push({\n\t\t\ttouchBreak: true,\n\t\t\tlife: touchPointLife\n\t\t});\n\t\t// On when menus are open, point down/up toggles an interactive mode.\n\t\t// We just need to rerender the menu system for it to respond.\n\t\tif (isMenuVisible()) renderMenus();\n\t}\n}\n\nfunction handleCanvasPointerMove(x, y) {\n\tif (pointerIsDown) {\n\t\tpointerScreen.x = x;\n\t\tpointerScreen.y = y;\n\t}\n}\n\n\n// Use pointer events if available, otherwise fallback to touch events (for iOS).\nif ('PointerEvent' in window) {\n\tcanvas.addEventListener('pointerdown', event => {\n\t\tevent.isPrimary && handleCanvasPointerDown(event.clientX, event.clientY);\n\t});\n\n\tcanvas.addEventListener('pointerup', event => {\n\t\tevent.isPrimary && handleCanvasPointerUp();\n\t});\n\n\tcanvas.addEventListener('pointermove', event => {\n\t\tevent.isPrimary && handleCanvasPointerMove(event.clientX, event.clientY);\n\t});\n\n\t// We also need to know if the mouse leaves the page. For this game, it's best if that\n\t// cancels a swipe, so essentially acts as a \"mouseup\" event.\n\tdocument.body.addEventListener('mouseleave', handleCanvasPointerUp);\n} else {\n\tlet activeTouchId = null;\n\tcanvas.addEventListener('touchstart', event => {\n\t\tif (!pointerIsDown) {\n\t\t\tconst touch = event.changedTouches[0];\n\t\t\tactiveTouchId = touch.identifier;\n\t\t\thandleCanvasPointerDown(touch.clientX, touch.clientY);\n\t\t}\n\t});\n\tcanvas.addEventListener('touchend', event => {\n\t\tfor (let touch of event.changedTouches) {\n\t\t\tif (touch.identifier === activeTouchId) {\n\t\t\t\thandleCanvasPointerUp();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\tcanvas.addEventListener('touchmove', event => {\n\t\tfor (let touch of event.changedTouches) {\n\t\t\tif (touch.identifier === activeTouchId) {\n\t\t\t\thandleCanvasPointerMove(touch.clientX, touch.clientY);\n\t\t\t\tevent.preventDefault();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}, { passive: false });\n}\n\n\n\n\n\n// index.js\n// ============================================================================\n// ============================================================================\n\nsetupCanvases();\n\n</script><style>body {\n\tmargin: 0;\n\tbackground-color: #000;\n\tbackground-image: radial-gradient(ellipse at top, #335476 0.0%, #31506e 11.1%, #304b67 22.2%, #2f4760 33.3%, #2d4359 44.4%, #2c3f51 55.6%, #2a3a4a 66.7%, #293643 77.8%, #28323d 88.9%, #262e36 100.0%);\n\theight: 100vh;\n\toverflow: hidden;\n\n\tfont-family: monospace;\n\tfont-weight: bold;\n\tletter-spacing: 0.06em;\n\tcolor: rgba(255, 255, 255, 0.75);\n}\n\n#c {\n\tdisplay: block;\n\ttouch-action: none;\n\ttransform: translateZ(0);\n}\n\n\n/*/////////////////////\n//        HUD        //\n/////////////////////*/\n\n\n.hud__score,\n.pause-btn {\n\tposition: fixed;\n\tfont-size: calc(14px + 2vw + 1vh);\n}\n\n.hud__score {\n\ttop: 0.65em;\n\tleft: 0.65em;\n\tpointer-events: none;\n\tuser-select: none;\n}\n\n.cube-count-lbl {\n\tfont-size: 0.46em;\n}\n\n.pause-btn {\n\tposition: fixed;\n\ttop: 0;\n\tright: 0;\n\tpadding: 0.8em 0.65em;\n}\n\n.pause-btn > div {\n\tposition: relative;\n\twidth: 0.8em;\n\theight: 0.8em;\n\topacity: 0.75;\n}\n\n.pause-btn > div::before,\n.pause-btn > div::after {\n\tcontent: '';\n\tdisplay: block;\n\twidth: 34%;\n\theight: 100%;\n\tposition: absolute;\n\tbackground-color: #fff;\n}\n\n.pause-btn > div::after {\n\tright: 0;\n}\n\n.slowmo {\n\tposition: fixed;\n\tbottom: 0;\n\twidth: 100%;\n\tpointer-events: none;\n\topacity: 0;\n\ttransition: opacity 0.4s;\n\twill-change: opacity;\n}\n\n.slowmo::before {\n\tcontent: 'SLOW-MO';\n\tdisplay: block;\n\tfont-size: calc(8px + 1vw + 0.5vh);\n\tmargin-left: 0.5em;\n\tmargin-bottom: 8px;\n}\n\n.slowmo::after {\n\tcontent: '';\n\tdisplay: block;\n\tposition: fixed;\n\tbottom: 0;\n\twidth: 100%;\n\theight: 1.5vh;\n\tbackground-color: rgba(0, 0, 0, 0.25);\n\tz-index: -1;\n}\n\n.slowmo__bar {\n\theight: 1.5vh;\n\tbackground-color: rgba(255, 255, 255, 0.75);\n\ttransform-origin: 0 0;\n}\n\n\n\n/*/////////////////////\n//       MENUS       //\n/////////////////////*/\n\n.menus::before {\n\tcontent: '';\n\tpointer-events: none;\n\tposition: fixed;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\tleft: 0;\n\tbackground-color: #000;\n\topacity: 0;\n\ttransition: opacity 0.2s;\n\ttransition-timing-function: ease-in;\n}\n\n.menus.has-active::before {\n\topacity: 0.08;\n\ttransition-duration: 0.4s;\n\ttransition-timing-function: ease-out;\n}\n\n.menus.interactive-mode::before {\n\topacity: 0.02;\n}\n\n\n\n/* Menu containers */\n.menu {\n\tpointer-events: none;\n\tposition: fixed;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\tleft: 0;\n\tdisplay: flex;\n\tflex-direction: column;\n\tjustify-content: center;\n\talign-items: center;\n\tuser-select: none;\n\ttext-align: center;\n\tcolor: rgba(255, 255, 255, 0.9);\n\topacity: 0;\n\tvisibility: hidden;\n\ttransform: translateY(30px);\n\ttransition-property: opacity, visibility, transform;\n\ttransition-duration: 0.2s;\n\ttransition-timing-function: ease-in;\n}\n\n.menu.active {\n\topacity: 1;\n\tvisibility: visible;\n\ttransform: translateY(0);\n\ttransition-duration: 0.4s;\n\ttransition-timing-function: ease-out;\n}\n\n.menus.interactive-mode .menu.active {\n\topacity: 0.6;\n}\n\n.menus:not(.interactive-mode) .menu.active > * {\n\tpointer-events: auto;\n}\n\n\n/* Common menu elements */\n\nh1 {\n\tfont-size: 4rem;\n\tline-height: 0.95;\n\ttext-align: center;\n\tfont-weight: bold;\n\tmargin: 0 0.65em 1em;\n}\n\nh2 {\n\tfont-size: 1.2rem;\n\tline-height: 1;\n\ttext-align: center;\n\tfont-weight: bold;\n\tmargin: -1em 0.65em 1em;\n}\n\n.final-score-lbl {\n\tfont-size: 5rem;\n\tmargin: -0.2em 0 0;\n}\n\n.high-score-lbl {\n\tfont-size: 1.2rem;\n\tmargin: 0 0 2.5em;\n}\n\nbutton {\n\tdisplay: block;\n\tposition: relative;\n\twidth: 200px;\n\tpadding: 12px 20px;\n\tbackground: transparent;\n\tborder: none;\n\toutline: none;\n\tuser-select: none;\n\tfont-family: monospace;\n\tfont-weight: bold;\n\tfont-size: 1.4rem;\n\tcolor: #fff;\n\topacity: 0.75;\n\ttransition: opacity 0.3s;\n}\n\nbutton::before {\n\tcontent: '';\n\tposition: absolute;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\tleft: 0;\n\tbackground-color: rgba(255, 255, 255, 0.15);\n\ttransform: scale(0, 0);\n\topacity: 0;\n\ttransition: opacity 0.3s, transform 0.3s;\n}\n\n/* No `:focus` styles because this is a mouse/touch game! */\nbutton:active {\n\topacity: 1;\n}\n\nbutton:active::before {\n\ttransform: scale(1, 1);\n\topacity: 1;\n}\n\n.credits {\n\tposition: fixed;\n\twidth: 100%;\n\tleft: 0;\n\tbottom: 20px;\n}\n\na {\n\tcolor: white;\n}\n\n/* Only enable hover state on large screens */\n@media (min-width: 1025px) {\n\tbutton:hover {\n\t\topacity: 1;\n\t}\n\n\tbutton:hover::before {\n\t\ttransform: scale(1, 1);\n\t\topacity: 1;\n\t}\n}\n</style>"}